//@author: a0111379h



	/**
	 * origin: D:\Work\NUS\CS2103\Projects\f112c-CS2103\Library\Conversion.cpp
	 */


#include "Conversion.h"

const int Conversion::base = 10;

Conversion::Conversion(void)
{
}

Conversion::~Conversion(void)
{
}

std::string Conversion::boolToString(bool isFloatingBool){
	if (isFloatingBool){
		return "1";
	} else{
		return "0";
		}
}

bool Conversion::stringToBool (std::string checkBool){
	if (checkBool == "1"){
		return true;
	} else{
		return false;
	    }
}

string Conversion::tmToString(Event convertEvent){
	std::ostringstream oss;

	oss << LABEL_STARTYEAR << convertEvent.getStartDate().tm_year << std::endl 
		<< LABEL_STARTMONTH << convertEvent.getStartDate().tm_mon << std::endl 
		<< LABEL_STARTDAY << convertEvent.getStartDate().tm_mday << std::endl 
		<< LABEL_STARTHOUR << convertEvent.getStartDate().tm_hour << std::endl 
		<< LABEL_STARTMIN << convertEvent.getStartDate().tm_min << std::endl;
	
	oss << LABEL_ENDYEAR << convertEvent.getEndDate().tm_year << std::endl 
		<< LABEL_ENDMONTH << convertEvent.getEndDate().tm_mon << std::endl 
		<< LABEL_ENDDAY << convertEvent.getEndDate().tm_mday << std::endl 
		<< LABEL_ENDHOUR << convertEvent.getEndDate().tm_hour << std::endl 
		<< LABEL_ENDMIN <<  convertEvent.getEndDate().tm_min;

	return oss.str();
}

std::string Conversion::eventToString(Event eventToDisplay){
					
	std::string eventName = eventToDisplay.getName();

	int tempStartDate = eventToDisplay.getStartDate().tm_mday;
    std::string startDate = intToString (tempStartDate);

	int tempStartMonth = eventToDisplay.getStartDate().tm_mon;
	std::string startMonth = intToMonth (tempStartMonth);

	int tempStartWDay = eventToDisplay.getStartDate().tm_wday;
	std::string startWDay = intToDayOfWeek (tempStartWDay);

	int tempStartHr  = eventToDisplay.getStartDate().tm_hour;
	int tempStartMin = eventToDisplay.getStartDate().tm_min;
	int tempStartTime = tempStartHr*100 + tempStartMin;
	std::string startTime = intToTime(tempStartTime);

	int tempEndDate = eventToDisplay.getEndDate().tm_mday;
	std::string endDate = intToString(tempEndDate);

	int tempEndMonth = eventToDisplay.getEndDate().tm_mon;
	std::string endMonth = intToString(tempEndMonth);

	int tempEndWDay = eventToDisplay.getEndDate().tm_wday;
	std::string endWDay = intToDayOfWeek (tempEndWDay);

	int tempEndHr  = eventToDisplay.getEndDate().tm_hour;
	int tempEndMin = eventToDisplay.getEndDate().tm_min;
	int tempEndTime = tempEndHr*100 + tempEndMin;
	std::string endTime = intToTime(tempEndTime);

	std::string description = eventToDisplay.getDescription();

	std::string tags = "";
	vector<std::string> tempTags = eventToDisplay.getTags(); 
					
	for (int i=0; i<tempTags.size(); i++){
		std::string temp = tempTags[i] + " ";
		tags+= temp;
	}

	std::string eventInString = "";
	eventInString += startDate + " ";
	eventInString += startMonth;
	eventInString += "(" + startWDay + ")" + "   ";
	eventInString += startTime;
	eventInString += " - ";
	eventInString += endDate + " ";
	eventInString += endMonth;
	eventInString += "(" + endWDay + ")" + "   ";
	eventInString += endTime;
	eventInString += "		";
	eventInString += eventName;
	eventInString += "		";
	eventInString += tags;
	
	if (description != ""){
	eventInString += "\n";
	eventInString += "*" + description;
	}
	
	eventInString += "\n\n";

	return eventInString;

}

Event Conversion::stringToEvent(std::string){
	Event a;

	return a;
}



int Conversion::monthToInt (std::string month){
	if(month == "jan" || month == "january"){
		return 0;
	} else if(month == "feb" || month == "february"){
		return 1;
	} else if(month == "mar" || month == "march"){
		return 2;
	} else if(month == "apr" || month == "april"){
		return 3;
	} else if(month == "may"){
		return 4;
	} else if(month == "jun" || month == "june"){
		return 5;
	} else if(month == "jul" || month == "july"){
		return 6;
	} else if(month == "aug" || month == "august"){
		return 7;
	} else if(month == "sep" || month == "september"){
		return 8;
	} else if(month == "oct" || month == "october"){
		return 9;
	} else if(month == "nov" || month == "november"){
		return 10;
	} else if(month == "dec" || month == "december"){
		return 11;
	} else {
		return -1;
	}
}

std::string Conversion::intToMonth (int monthInNum){
	if(monthInNum == 0){
		return "jan";
	} else if(monthInNum  == 1){
		return "feb";
	} else if(monthInNum  == 2){
		return "mar";
	} else if(monthInNum  == 3){
		return "apr";
	} else if(monthInNum  == 4){
		return "may";
	} else if(monthInNum  == 5){
		return "jun";
	} else if(monthInNum  == 6){
		return "jul";
	} else if(monthInNum  == 7){
		return "aug";
	} else if(monthInNum  == 8){
		return "sep";
	} else if(monthInNum  == 9){
		return "oct";
	} else if(monthInNum  == 10){
		return "nov";
	} else if(monthInNum  == 11){
		return "dec";
	} else {
		return "Invalid month";
	}
}



std::string Conversion::intToDayOfWeek (int dayInNum){
	if(dayInNum == 0){
		return "sun";
	} else if (dayInNum == 1){
		return "mon";
	} else if (dayInNum == 2){
		return "tues";
	} else if (dayInNum == 3){
		return "wed";
	} else if (dayInNum == 4){
		return "thurs";
	} else if (dayInNum == 5){
		return "fri";
	} else if (dayInNum == 6){
		return "sat";
	} else{
		return "Invalid day";
	}
}

int Conversion::dayOfWeekToInt (std::string day){
	if(day == "sun" || day == "sunday"){
		return 0;
	} else if (day == "mon" || day == "monday"){
		return 1;
	} else if (day == "tues" || day == "tuesday"){
		return 2;
	} else if (day == "wed" || day == "wednesday"){
		return 3;
	} else if (day == "thurs" || day == "thursday"){
		return 4;
	} else if (day == "fri" || day == "friday"){
		return 5;
	} else if (day == "sat" || day == "saturday"){
		return 6;
	} else{
		return -1;
	}
}

std::string Conversion::intToTime (int timeInInt){
	int hours;
	int minutes;
	bool afterTwelve = false;
	std::ostringstream oss;
	hours = timeInInt/100;
	minutes = timeInInt%100;

	if(hours > 12){
		hours = hours - 12;
		afterTwelve = true;
	}
	
	if(afterTwelve){
		oss << hours << "." << minutes << "pm";
	} else {
		oss << hours << "." << minutes << "am";
	}
	
	return oss.str();
}

int Conversion::timeToInt (std::string time){
	std::string::size_type strDotIndex;
	std::string strHour;
	std::string strMinute;
	int hours;
	int minutes;
	int combinedHoursMinutes;
	bool afterTwelve = false;

	if(time.find("am") != std::string::npos){
		afterTwelve = false;
	} else if(time.find("pm") != std::string::npos){
		afterTwelve = true;
	}

	strDotIndex = time.find_first_of(".");
	if(strDotIndex != std::string::npos){
		strHour = time.substr(0,strDotIndex);
		strMinute = time.substr(strDotIndex+1);
	} else {
		strHour = time.substr(0,strDotIndex);
	}

	if(afterTwelve){
		hours = std::stoi(strHour) + 12;
	} else {
		hours = std::stoi(strHour);
	}

	if(strDotIndex != std::string::npos){
		minutes = std::stoi(strMinute);
	} else {
		minutes = 0;
	}

	combinedHoursMinutes = hours*100 + minutes;
	return combinedHoursMinutes;
}

std::string Conversion::intToString (int num){
	std::string outString;
	std::ostringstream oss;
	oss << num;
	return oss.str();
}
int Conversion::stringToInt (std::string str){
	int outNum;
	std::istringstream in(str);
	in >> outNum;
	return outNum;
}

std::string Conversion::toLowerCase(std::string word){
	for (int i=0;i<word.size();i++){
		 word[i] = tolower(word[i]);
	 }
	return word;
 }

int Conversion::determineLastDayOfMth(int month, int year){
	if (month == 0 || month == 2 || month == 4 || month == 6 || month == 7 || month == 9 || month == 11){
		return 31;
	} else if (month == 3 || month == 5 || month == 8 || month == 10){
		return 30;
	} else if (isLeapYear(year)){
		return 29;
	} else {
		return 28;
	}
}

bool Conversion::isLeapYear(int year){
	if (year % 4 != 0) return false;
	if (year % 400 == 0) return true;
	if (year % 100 == 0) return false;
	return true;
}
	// End of segment: D:\Work\NUS\CS2103\Projects\f112c-CS2103\Library\Conversion.cpp





	/**
	 * origin: D:\Work\NUS\CS2103\Projects\f112c-CS2103\Library\Conversion.h
	 */


#pragma once

#ifndef CONVERSION_H
#define CONVERSION_H

#include <iostream>
#include <string>
#include <sstream>
#include <cctype>

#include "Event.h"

const string LABEL_STARTYEAR = "Start Year: ";
const string LABEL_STARTMONTH = "Start Month: ";
const string LABEL_STARTDAY = "Start Day: ";
const string LABEL_STARTHOUR = "Start Hour: ";
const string LABEL_STARTMIN = "Start Min: ";
const string LABEL_ENDYEAR = "End Year: ";
const string LABEL_ENDMONTH = "End Month: ";
const string LABEL_ENDDAY = "End Day: ";
const string LABEL_ENDHOUR = "End Hour: ";
const string LABEL_ENDMIN = "End Min: ";

class Conversion
{
public:
	// Variables
	static const int base;

	Conversion(void);
	~Conversion(void);

	std::string boolToString(bool);
	bool stringToBool (std::string);

	std::string eventToString(Event);
	Event stringToEvent(std::string);

	int monthToInt (std::string);
	std::string intToMonth (int);

	std::string intToDayOfWeek (int);
	int dayOfWeekToInt (std::string);

	std::string intToTime (int);
	int timeToInt (std::string);

	std::string intToString (int);
	int stringToInt (std::string);

	std::string toLowerCase(std::string);

	std::string tmToString(Event convertEvent);

	int determineLastDayOfMth(int month, int year);
	bool isLeapYear(int year);
};

#endif


	// End of segment: D:\Work\NUS\CS2103\Projects\f112c-CS2103\Library\Conversion.h





	/**
	 * origin: D:\Work\NUS\CS2103\Projects\f112c-CS2103\Library\EventOrganiser.cpp
	 */

//returns a vector of days for the wanted range of dates.
vector<struct tm> EventOrganiser::eventDateToVector(Event showEventDates){
	
	struct tm tempStartDate = showEventDates.getStartDate();
	int startday = tempStartDate.tm_mday;
	int startmonth = tempStartDate.tm_mon;
	int startyear = tempStartDate.tm_year;
	
	struct tm tempEndDate = showEventDates.getEndDate();
	int endday = tempEndDate.tm_mday;
	int endmonth = tempEndDate.tm_mon;
	int endyear = tempEndDate.tm_year;

	vector<struct tm> datesToShow;
	struct tm tempTM;

	int i, j, k;
	for(k = startyear; k <= endyear; k++){
		tempTM.tm_year = k;
		if(k == endyear){
			for(j = startmonth; j <= endmonth; j++){
				tempTM.tm_mon = j;
				if(j < endmonth){
					for(i = startday; i <= convertor.determineLastDayOfMth(j,k); i++){
						tempTM.tm_mday = i;
						datesToShow.push_back(tempTM);
					}
					//reset startday count to start of month
					startday = 1;
				} else if(j == endmonth){
					for(i = startday; i <= endday; i++){
						tempTM.tm_mday = i;
						datesToShow.push_back(tempTM);
					}
				} 
			}
		} else if(k < endyear){
			for(j = startmonth; j <= TOTAL_MONTHS_IN_A_YEAR; j++){
				tempTM.tm_mon = j;
				for(i = startday; i <= convertor.determineLastDayOfMth(j,k); i++){
					tempTM.tm_mday = i;
					datesToShow.push_back(tempTM);
				}
				//reset startday count to start of month
				startday = 1;
			}
			//reset startmonth to start of year
			startmonth = 0;
		}
	}

	return datesToShow;
}

	// End of segment: D:\Work\NUS\CS2103\Projects\f112c-CS2103\Library\EventOrganiser.cpp





	/**
	 * origin: D:\Work\NUS\CS2103\Projects\f112c-CS2103\Library\InputStringSplit.cpp
	 */


#include "InputStringSplit.h"

const std::string InputStringSplit::EXTRACT_FIRST_WORD = "extractFirstWord";
const std::string InputStringSplit::EXTRACT_DETAILS = "extractDetails";
const std::string InputStringSplit::EXTRACT_DEL_DONE_EVENT_NAME = "extractDelDoneEventName";
const std::string InputStringSplit::EXTRACT_EDIT_EVENT_NAME = "extractEditEventName";
const std::string InputStringSplit::REMOVE_EDIT_EVENT_NAME = "removeEditEventName";
const std::string InputStringSplit::FRAGMENT_STRING = "fragmentString";
const std::string InputStringSplit::FRAGMENT_SHOW_STRING = "fragmentShowString";

const std::string InputStringSplit::CONVERT_NORMAL_TO_FLOAT = "to>>>float";

InputStringSplit::InputStringSplit(){
}

//Finds the first word and extracts it out. Throws exception if no input is found. Returns the extracted string.
std::string InputStringSplit::extractFirstWord(std::string input){
	logger.logParserEnterFunc(EXTRACT_FIRST_WORD);

	bool missingInput = true;
	for (unsigned int i = 0; i < input.size() && missingInput; i++){
		if(isalnum(input[i])){
			missingInput = false;
		}
	}
	if(missingInput){
		logger.logParserError(ParserExceptions::ERROR_MISSING_INPUT);
		throw ParserExceptions(ParserExceptions::ERROR_MISSING_INPUT);
	}
	
	std::string::size_type strCutIndex;
	std::string tempStr;
	
	strCutIndex = input.find_first_not_of(" ");
	if(strCutIndex == std::string::npos){
		logger.logParserError(ParserExceptions::ERROR_MISSING_INPUT);
		throw ParserExceptions(ParserExceptions::ERROR_MISSING_INPUT);
	}
	tempStr = input.substr(strCutIndex);
	strCutIndex = tempStr.find_first_of(" ");
	tempStr = tempStr.substr(0,strCutIndex);
	for(unsigned int i = 0; i < tempStr.size(); i++){
		tempStr[i] = std::tolower(tempStr[i]);
	}
	
	if(tempStr.empty()){
		logger.logParserError(ParserExceptions::ERROR_MISSING_INPUT);
		throw ParserExceptions(ParserExceptions::ERROR_MISSING_INPUT);
	}
	return tempStr;
}

//Remove the first word and extract out what comes AFTER the first word.
//Throws exception if no input is found after the spacing. Returns the extracted string.
std::string InputStringSplit::extractDetails(std::string input){
	logger.logParserEnterFunc(EXTRACT_DETAILS);
	assert(!input.empty());

	bool missingInput = true;
	for (unsigned int i = 0; i < input.size() && missingInput; i++){
		if(isalnum(input[i])){
			missingInput = false;
		}
	}
	if(missingInput){
		logger.logParserError(ParserExceptions::ERROR_INSUFFICIENT_INFO);
		throw ParserExceptions(ParserExceptions::ERROR_INSUFFICIENT_INFO);
	}

	std::string::size_type strCutIndex;
	strCutIndex = input.find_first_not_of(" ");
	if(strCutIndex == std::string::npos){
		logger.logParserError(ParserExceptions::ERROR_MISSING_INPUT);
		throw ParserExceptions(ParserExceptions::ERROR_MISSING_INPUT);
	}
	std::string tempStr = input.substr(strCutIndex);
	strCutIndex = tempStr.find_first_of(" ");
	if(strCutIndex == std::string::npos){
		logger.logParserError(ParserExceptions::ERROR_MISSING_INPUT);
		throw ParserExceptions(ParserExceptions::ERROR_MISSING_INPUT);
	}
	tempStr = tempStr.substr(strCutIndex);

	strCutIndex = tempStr.find_first_not_of(" ");
	if(strCutIndex == std::string::npos){
		logger.logParserError(ParserExceptions::ERROR_INSUFFICIENT_INFO);
		throw ParserExceptions(ParserExceptions::ERROR_INSUFFICIENT_INFO);
	}

	tempStr = tempStr.substr(strCutIndex);
	if(tempStr.empty()){
		logger.logParserError(ParserExceptions::ERROR_MISSING_INPUT);
		throw ParserExceptions(ParserExceptions::ERROR_MISSING_INPUT);
	}
	return tempStr;
}

//Finds the event name and index by searching for ';', and extracts this info.
//Throws exception if no event name/ event index is found. Returns the extracted event name/index in string format.
std::string InputStringSplit::extractEditEventName(std::string input){
	logger.logParserEnterFunc(EXTRACT_EDIT_EVENT_NAME);
	assert(!input.empty());

	if(input.empty()){
		logger.logParserError(ParserExceptions::ERROR_MISSING_INPUT);
		throw ParserExceptions(ParserExceptions::ERROR_MISSING_INPUT);
	}
	std::string::size_type strCutIndex;
	std::string tempStr;
	
	strCutIndex = input.find_last_of(";");
	if(strCutIndex == std::string::npos){
		logger.logParserError(ParserExceptions::ERROR_MISSING_INDEX);
		throw ParserExceptions(ParserExceptions::ERROR_MISSING_INDEX);
	}
	tempStr = input.substr(0,strCutIndex);
	strCutIndex = tempStr.find_last_not_of(" ");
	if (strCutIndex == std::string::npos){
		logger.logParserError(ParserExceptions::ERROR_MISSING_INDEX);
		throw ParserExceptions(ParserExceptions::ERROR_MISSING_INDEX);
	} else {
		tempStr = tempStr.substr(0,strCutIndex+1);
	}

	if(tempStr.empty()){
		logger.logParserError(ParserExceptions::ERROR_MISSING_INPUT);
		throw ParserExceptions(ParserExceptions::ERROR_MISSING_INPUT);
	}
	return tempStr;
}

//Removes the event name/index from the input string.
//Returns the remaining string after removing the event name/event index.
std::string InputStringSplit::removeEditEventName(std::string input, std::string eventName){
	logger.logParserEnterFunc(REMOVE_EDIT_EVENT_NAME);
	assert(!input.empty());

	if(input.empty()){
		logger.logParserError(ParserExceptions::ERROR_MISSING_INPUT);
		throw ParserExceptions(ParserExceptions::ERROR_MISSING_INPUT);
	}
	std::string::size_type strCutIndex;
	strCutIndex = input.find(eventName);
	strCutIndex = input.find_first_not_of(" ;",strCutIndex+eventName.size());
	std::string tempStr;
	if(strCutIndex != std::string::npos){
		tempStr = input.substr(strCutIndex);
	} else {
		tempStr = CONVERT_NORMAL_TO_FLOAT;
	}

	if(tempStr.empty()){
		logger.logParserError(ParserExceptions::ERROR_MISSING_INPUT);
		throw ParserExceptions(ParserExceptions::ERROR_MISSING_INPUT);
	}
	return tempStr;
}

//Splits the input string into a vector of strings for add events, by finding spaces, dots and numbers and splits the string accordingly. 
//Replaces '-' with the word "to". Throws exception if there is no input. Returns a vector of strings.
std::vector<std::string> InputStringSplit::fragmentString(std::string input){
	logger.logParserEnterFunc(FRAGMENT_STRING);
	assert(!input.empty());

	if(input.empty()){
		logger.logParserError(ParserExceptions::ERROR_INSUFFICIENT_INFO);
		throw ParserExceptions(ParserExceptions::ERROR_INSUFFICIENT_INFO);
	}
	std::string::size_type strCutIndex;
	std::vector<std::string> fragmentedWords;
	std::string tempString;
	bool endOfString = false;
	bool dotFound = false;
	int dotCounter = 0;

	while(!endOfString){
		strCutIndex = input.find_first_of("- 0123456789");
		if(strCutIndex == std::string::npos){
			fragmentedWords.push_back(input.substr(0,strCutIndex));
			endOfString = true;
		} else {
			if(input.at(strCutIndex) == '-'){
				if(strCutIndex != 0){
					fragmentedWords.push_back(input.substr(0,strCutIndex));
				}
				fragmentedWords.push_back("to");
				strCutIndex = input.find_first_not_of(" -.",strCutIndex);
			} else if(input.at(strCutIndex) == ' '){
				if(strCutIndex != 0){
					fragmentedWords.push_back(input.substr(0,strCutIndex+1));
				}
				strCutIndex = input.find_first_not_of(" ",strCutIndex);
			} else {
				if(strCutIndex != 0){
					fragmentedWords.push_back(input.substr(0,strCutIndex));
					input = input.substr(strCutIndex);
					strCutIndex = 0;
				}
				strCutIndex = input.find_first_not_of("0123456789.",strCutIndex);
				if(strCutIndex != std::string::npos){
					if(input[strCutIndex] == ' '){
						fragmentedWords.push_back(input.substr(0,strCutIndex+1));
					} else {
						fragmentedWords.push_back(input.substr(0,strCutIndex));
					}
				} else {
					fragmentedWords.push_back(input.substr(0,strCutIndex));
				}
			}
			if(dotFound){
				dotCounter++;
			}
			if(dotCounter == SECOND_INSTANCE && fragmentedWords.size() >= SECOND_INSTANCE){
				fragmentedWords[fragmentedWords.size()-SECOND_INSTANCE] = 
					fragmentedWords[fragmentedWords.size()-SECOND_INSTANCE] + fragmentedWords[fragmentedWords.size()-1];
				fragmentedWords.pop_back();
				dotFound = false;
				dotCounter = 0;
			}
			if(strCutIndex == std::string::npos){
				endOfString = true;
			} else {
				input = input.substr(strCutIndex);
			}
		}
	}
	return fragmentedWords;
}
	// End of segment: D:\Work\NUS\CS2103\Projects\f112c-CS2103\Library\InputStringSplit.cpp





	/**
	 * origin: D:\Work\NUS\CS2103\Projects\f112c-CS2103\Library\InputStringSplit.h
	 */


#pragma once

#ifndef INPUTSTRINGSPLIT_H
#define INPUTSTRINGSPLIT_H

#include <string>
#include <vector>
#include <iostream>
#include <assert.h>
#include <cctype>
#include "ParserExceptions.h"
#include "ParserLog.h"

class InputStringSplit {
private: 
	ParserLog logger;
	
public:
	static const std::string EXTRACT_FIRST_WORD;
	static const std::string EXTRACT_DETAILS;
	static const std::string EXTRACT_DEL_DONE_EVENT_NAME;
	static const std::string EXTRACT_EDIT_EVENT_NAME;
	static const std::string REMOVE_EDIT_EVENT_NAME;
	static const std::string FRAGMENT_STRING;
	static const std::string FRAGMENT_SHOW_STRING;

	static const std::string CONVERT_NORMAL_TO_FLOAT;
	static const int SECOND_INSTANCE = 2;

	InputStringSplit();

	std::string extractFirstWord(std::string);
	std::string extractDetails(std::string);
	std::string extractEditEventName(std::string);
	std::string removeEditEventName(std::string, std::string);
	std::vector<std::string> fragmentString(std::string);
	//std::vector<std::string> fragmentShowString(std::string);
};

#endif
	// End of segment: D:\Work\NUS\CS2103\Projects\f112c-CS2103\Library\InputStringSplit.h





	/**
	 * origin: D:\Work\NUS\CS2103\Projects\f112c-CS2103\Library\Parser.cpp
	 */


#include "Parser.h"

const std::string Parser::TOKENISE_ORIGINAL_STRING = "tokeniseOriginalString";

Parser::Parser(std::string input)
{
	keywordCommands[0] = "add";
	keywordCommands[1] = "del";
	keywordCommands[2] = "delete";
	keywordCommands[3] = "edit";
	keywordCommands[4] = "show";
	keywordCommands[5] = "search";
	keywordCommands[6] = "undo";
	keywordCommands[7] = "redo";
	keywordCommands[8] = "done";
	keywordCommands[9] = "completed";
	keywordCommands[10] = "complete";
	keywordCommands[11] = "uncomplete";
	keywordCommands[12] = "undone";

	logger.logParserStart(input);
	original = input;
	this->processInput();
}

Parser::~Parser(void)
{
}

	//GETTERS
Parser::CommandType Parser::getCommandType() {
	return typeOfCommand;
}

std::string Parser::getCommand() {
	return command;
}

std::string Parser::getDetails() {
	return details;
}

std::string Parser::getOriginal() {
	return original;
}

Event Parser::getEvent() {
	return tempEventStore;
}

std::string Parser::getNameOfEvent() {
	return nameOfEvent;
}

//Function takes in the input from the user and determines the command type and organises the information provided into an Event form. Throws exception if the command is unknown.
//These are done by calling InputStringSplit object to separate the input string into its components, and then calling the ParserProcessor object to retrieve the information 
//and organise them into the Event format. 
//Receives any thrown exceptions from the InputStringSplit and ParserProcessor objects and sets the feedback to the user, to be returned to Logic.
void Parser::processInput() {
	try {
		tokenizeOriginalString();
		determineCommandType();
		logger.logParserSuccess(original);
	} catch (ParserExceptions& e) {
		tempEventStore.setFeedback(createFeedback(e.getExceptionCode()));
		typeOfCommand = Parser::ERROR_;
		logger.logParserFailure(original);
	}
}

//Function splits the input string into command and details.
void Parser::tokenizeOriginalString() {
	logger.logParserEnterFunc(TOKENISE_ORIGINAL_STRING);

	try {
		command = splitter.extractFirstWord(original);
		if (checkCommandExist()) {
			if (!checkCommandUndoRedo()) {
				details = splitter.extractDetails(original);
			}
		} else {
			details = original;
			command = "add";
		}
	} catch (ParserExceptions& e) {
		throw e;
	}
}

void Parser::determineCommandType() {
	try {
		if (command == "add") {
			determineAddCommand();
		} else if (command == "delete" || command == "del") {
			determineDelCommand();
		} else if (command == "edit") {
			determineEditCommand();
		} else if (command == "show") {
			determineShowCommand();
		} else if (command == "done" || command == "completed" || command == "complete") {
			determineCompleteCommand();
		} else if (command == "uncomplete" || command == "undone"){
			determineUncompleteCommand();
		} else if (command == "search" || command == "undo" || command == "redo") {
			determineOtherCommand();
		} else {
			throw ParserExceptions(ParserExceptions::ERROR_UNKNOWN_COMMAND);
		}
	} catch (ParserExceptions& e) {
		throw e;
	}
	return;
}

	// End of segment: D:\Work\NUS\CS2103\Projects\f112c-CS2103\Library\Parser.cpp





	/**
	 * origin: D:\Work\NUS\CS2103\Projects\f112c-CS2103\Library\Parser.cpp
	 */


//Sets the feedback based on what exception code was thrown to be returned to Logic and displayed to the user.
std::string Parser::createFeedback(std::string errorCode) {
	std::string tempFeedback;
	if (errorCode == ParserExceptions::ERROR_MISSING_INPUT) {
		tempFeedback = "Error: Invalid input.";
	}
	if (errorCode == ParserExceptions::ERROR_NO_NAME) {
		tempFeedback = "Error: No event name found.";
	}
	if (errorCode == ParserExceptions::ERROR_TOO_MANY_DATES) {
		tempFeedback = "Error: Exceeded maximum of 2 date inputs.";
	}
	if (errorCode == ParserExceptions::ERROR_TOO_MANY_TIMES) {
		tempFeedback = "Error: Exceeded maximum of 2 time inputs.";
	}
	if (errorCode == ParserExceptions::ERROR_MISSING_DAY) {
		tempFeedback = "Error: No day input found before month.";
	}
	if (errorCode == ParserExceptions::ERROR_UNUSED_INFORMATION) {
		tempFeedback = "Error: Wrong formatting, not all information has been successfully recorded.";
	}
	if (errorCode == ParserExceptions::ERROR_MISSING_HOUR_MIN) {
		tempFeedback = "Error: No hour/minute input before am/pm.";
	}
	if (errorCode == ParserExceptions::ERROR_MISSING_INDEX) {
		tempFeedback = "Error: No event index or event name found.";
	}
	if (errorCode == ParserExceptions::ERROR_INSUFFICIENT_INFO) {
		tempFeedback = "Error: Not enough information to execute command.";
	}
	if (errorCode == ParserExceptions::ERROR_UNKNOWN_COMMAND) {
		tempFeedback = "Error: Unknown command.";
	}
	if (errorCode == ParserExceptions::ERROR_UNKNOWN_DATE) {
		tempFeedback = "Error: Unknown date input.";
	}
	if (errorCode == ParserExceptions::ERROR_UNKNOWN_HOUR) {
		tempFeedback = "Error: Invalid hour input for time.";
	}
	if (errorCode == ParserExceptions::ERROR_UNKNOWN_MINUTE) {
		tempFeedback = "Error: Invalid minutes input for time.";
	}
	if (errorCode == ParserExceptions::ERROR_START_AFTER_END) {
		tempFeedback = "Error: Start day is later than End day";
	}
	if (errorCode == ParserExceptions::ERROR_NO_SHOW) {
		tempFeedback = "Error: No registered show found. Please use search instead.";
	}
	if (errorCode == ParserExceptions::ERROR_DUE_TOO_MANY_DATES) {
		tempFeedback = "Error: Exceeded maximum of 1 date input for deadline events.";
	}
	if (errorCode == ParserExceptions::ERROR_DUE_TOO_MANY_TIMES) {
		tempFeedback = "Error: Exceeded maximum of 1 time input for deadline events";
	}
	if (errorCode == ParserExceptions::ERROR_INVALID_YEAR) {
		tempFeedback = "Error: Year input out of range. Accepted range: 1971 - 2999";
	}
	if (errorCode == ParserExceptions::ERROR_NO_EDIT_TO_DEADLINE) {
		tempFeedback = "Error: Cannot edit to deadline events";
	}
	return tempFeedback;
}

	// End of segment: D:\Work\NUS\CS2103\Projects\f112c-CS2103\Library\Parser.cpp





	/**
	 * origin: D:\Work\NUS\CS2103\Projects\f112c-CS2103\Library\Parser.h
	 */


#pragma once

#ifndef PARSER_H
#define PARSER_H

#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include "Event.h"
#include "InputStringSplit.h"
#include "ParserProcessor.h"
#include "ParserLog.h"

class Parser
{
public:
	//constructor, destructor
	Parser(std::string);
	~Parser(void);

	enum CommandType {
		ADDFLOAT, 
		ADD, 
		DELETE_, 
		EDIT,
		ERROR_,
		SEARCH,
		SHOW,
		SHOWFLOAT,
		SHOWALL,
		SHOWIMPORTANT,
		SHOWALLIMPORTANT,
		SHOWCOMPLETE,
		SHOWWEEK,
		SHOWMONTH,
		UNDO,
		REDO,
		COMPLETE,
		UNCOMPLETE
	};

	static const std::string TOKENISE_ORIGINAL_STRING;

private:
	ParserLog logger;
	InputStringSplit splitter;
	ParserProcessor processor;

	Parser::CommandType typeOfCommand;
	std::string command;
	std::string details;
	std::string original;
	Event tempEventStore;
	std::string nameOfEvent;

	static const int NUMBER_OF_KEYWORDS_COMMANDS = 13;
	std::string keywordCommands[NUMBER_OF_KEYWORDS_COMMANDS];

public:
	//getters
	Parser::CommandType getCommandType();
	std::string getCommand();
	std::string getDetails();
	std::string getOriginal();
	Event getEvent();
	std::string getNameOfEvent();

	//main methods
	void processInput();
	void tokenizeOriginalString();
	void determineCommandType();
	void determineAddCommand();
	void determineDelCommand();
	void determineEditCommand();
	void determineShowCommand();
	void determineCompleteCommand();
	void determineUncompleteCommand();
	void determineOtherCommand();
	bool checkCommandExist();
	bool checkCommandUndoRedo();
	std::string createFeedback(std::string);
};		

#endif
	// End of segment: D:\Work\NUS\CS2103\Projects\f112c-CS2103\Library\Parser.h





	/**
	 * origin: D:\Work\NUS\CS2103\Projects\f112c-CS2103\Library\ParserExceptions.cpp
	 */


#include "ParserExceptions.h"

const std::string ParserExceptions::ERROR_MISSING_INPUT = "PS000";
const std::string ParserExceptions::ERROR_NO_NAME = "PS001";
const std::string ParserExceptions::ERROR_TOO_MANY_DATES = "PS002";
const std::string ParserExceptions::ERROR_TOO_MANY_TIMES = "PS003";
const std::string ParserExceptions::ERROR_MISSING_DAY = "PS004";
const std::string ParserExceptions::ERROR_UNUSED_INFORMATION = "PS005";
const std::string ParserExceptions::ERROR_MISSING_HOUR_MIN = "PS006";
const std::string ParserExceptions::ERROR_TOO_MANY_DEL = "PS007";
const std::string ParserExceptions::ERROR_MISSING_INDEX = "PS008";
const std::string ParserExceptions::ERROR_INSUFFICIENT_INFO = "PS009";
const std::string ParserExceptions::ERROR_UNKNOWN_COMMAND = "PS010";
const std::string ParserExceptions::ERROR_UNKNOWN_DATE = "PS011";
const std::string ParserExceptions::ERROR_UNKNOWN_HOUR = "PS012";
const std::string ParserExceptions::ERROR_UNKNOWN_MINUTE = "PS013";
const std::string ParserExceptions::ERROR_START_AFTER_END = "PS014";
const std::string ParserExceptions::ERROR_NO_SHOW = "PS015";
const std::string ParserExceptions::ERROR_DUE_TOO_MANY_DATES = "PS016";
const std::string ParserExceptions::ERROR_DUE_TOO_MANY_TIMES = "PS017";
const std::string ParserExceptions::ERROR_INVALID_YEAR = "PS018";
const std::string ParserExceptions::ERROR_NO_EDIT_TO_DEADLINE = "PS019";

ParserExceptions::ParserExceptions(std::string errorCode) {
	exceptionCode = errorCode;
}

std::string ParserExceptions::getExceptionCode() {
	return exceptionCode;
}



	// End of segment: D:\Work\NUS\CS2103\Projects\f112c-CS2103\Library\ParserExceptions.cpp





	/**
	 * origin: D:\Work\NUS\CS2103\Projects\f112c-CS2103\Library\ParserExceptions.h
	 */


#pragma once

#ifndef PARSEREXCEPTIONS_H
#define PARSEREXCEPTIONS_H

#include <iostream>
#include <string>

class ParserExceptions {
private:
	std::string exceptionCode;

public:
	static const std::string ERROR_MISSING_INPUT;
	static const std::string ERROR_NO_NAME;
	static const std::string ERROR_TOO_MANY_DATES;
	static const std::string ERROR_TOO_MANY_TIMES;
	static const std::string ERROR_MISSING_DAY;
	static const std::string ERROR_UNUSED_INFORMATION;
	static const std::string ERROR_MISSING_HOUR_MIN;
	static const std::string ERROR_TOO_MANY_DEL;
	static const std::string ERROR_MISSING_INDEX;
	static const std::string ERROR_INSUFFICIENT_INFO;
	static const std::string ERROR_UNKNOWN_COMMAND;
	static const std::string ERROR_UNKNOWN_DATE;
	static const std::string ERROR_UNKNOWN_HOUR;
	static const std::string ERROR_UNKNOWN_MINUTE;
	static const std::string ERROR_START_AFTER_END;
	static const std::string ERROR_NO_SHOW;
	static const std::string ERROR_DUE_TOO_MANY_DATES;
	static const std::string ERROR_DUE_TOO_MANY_TIMES;
	static const std::string ERROR_INVALID_YEAR;
	static const std::string ERROR_NO_EDIT_TO_DEADLINE;
	
	ParserExceptions(std::string);

	std::string getExceptionCode();
};

#endif

	// End of segment: D:\Work\NUS\CS2103\Projects\f112c-CS2103\Library\ParserExceptions.h





	/**
	 * origin: D:\Work\NUS\CS2103\Projects\f112c-CS2103\Library\ParserProcessor.cpp
	 */


#include "ParserProcessor.h"

const std::string ParserProcessor::LOCKUP_USED_INFORMATION = "USED";

const std::string ParserProcessor::PROCESS_ADD_EVENT = "processAddEvent";
const std::string ParserProcessor::PROCESS_EDIT_EVENT = "processEditEvent";
const std::string ParserProcessor::ADD_EVENT_CORRECTOR = "addEventCorrector";
const std::string ParserProcessor::EDIT_EVENT_CORRECTOR = "editEventCorrector";
const std::string ParserProcessor::EVENT_MK_TIME_CORRECTOR = "eventMkTimeCorrector";
const std::string ParserProcessor::PROCESS_SHOW_EVENT = "processShowEvent";
const std::string ParserProcessor::IDENTIFY_EVENT_NAME = "Event name identified";
const std::string ParserProcessor::IDENTIFY_DATE = "Date identified";
const std::string ParserProcessor::IDENTIFY_DAY = "Day identified";
const std::string ParserProcessor::IDENTIFY_TIME = "Time identified";
const std::string ParserProcessor::IDENTIFY_DEADLINE = "Deadline identified";
const std::string ParserProcessor::IDENTIFY_IMPORTANCE = "Importance identified";
const std::string ParserProcessor::SYSTEM_SHOW = "System show identified";
const std::string ParserProcessor::SHOW_YEAR = "Show by year identified";

const std::string ParserProcessor::CONVERT_NORMAL_TO_FLOAT = "to>>>float";

ParserProcessor::ParserProcessor() {
	keywordMonths[0] = "jan";
	keywordMonths[1] = "january";
	keywordMonths[2] = "feb";
	keywordMonths[3] = "february";
	keywordMonths[4] = "mar";
	keywordMonths[5] = "march";
	keywordMonths[6] = "apr";
	keywordMonths[7] = "april";
	keywordMonths[8] = "may";
	keywordMonths[9] = "jun";
	keywordMonths[10] = "june";
	keywordMonths[11] = "jul";
	keywordMonths[12] = "july";
	keywordMonths[13] = "aug";
	keywordMonths[14] = "august";
	keywordMonths[15] = "sep";
	keywordMonths[16] = "september";
	keywordMonths[17] = "oct";
	keywordMonths[18] = "october";
	keywordMonths[19] = "nov";
	keywordMonths[20] = "november";
	keywordMonths[21] = "dec";
	keywordMonths[22] = "december";
	
	keywordTime[0] = "am";
	keywordTime[1] = "pm";

	keywordDay[0] = "today";
	keywordDay[1] = "tdy";
	keywordDay[2] = "tomorrow";
	keywordDay[3] = "tmr";
	keywordDay[4] = "mon";
	keywordDay[5] = "monday";
	keywordDay[6] = "tues";
	keywordDay[7] = "tuesday";
	keywordDay[8] = "wed";
	keywordDay[9] = "wednesday";
	keywordDay[10] = "thurs";
	keywordDay[11] = "thursday";
	keywordDay[12] = "fri";
	keywordDay[13] = "friday";
	keywordDay[14] = "sat";
	keywordDay[15] = "saturday";
	keywordDay[16] = "sun";
	keywordDay[17] = "sunday";

	matchFound = false;
	startDayFound = false;
	endDayFound = false;
	startTimeFound = false;
	endTimeFound = false;
	afterTwelve = false;
	nameFound = false;
	firstTriggerKeyword = false;
	nameIndex = INVALID_NUMBER;
	semiColonIndex = INVALID_NUMBER;
	toFound = false;
	deadlineFound = false;
	importanceFound = false;
	normalToFloat = false;

	oneMatchFound = false;
	twoMatchFound = false;
	systemShowWeek = false;
	systemShowMonth = false;
	systemShowYear = false;
	systemShowOthers = false;
	userShowDay = false;
	userShowRangeOfDays = false;
	userShowMonth = false;
	userShowRangeOfMonths = false;

	time_t t = time(0);
	now = localtime(&t);
}

//Process the fragmented vector of strings that contains all the information of the Event by calling further functions to identify the event name, day/date,
//time, deadline and importance of the Event. It then checks what information has been found, and throws exceptions if the basic requirements are not met.
//Lastly, it calls two correctors to correct the details and finalise the contents in the Event.
//Returns the final completed Event that has extracted and stored all the information that was initially passed in as a vector.
Event ParserProcessor::processAddEvent(std::vector<std::string> fragmentedWords_) {
	logger.logParserEnterFunc(PROCESS_ADD_EVENT);

	fragmentedWords = fragmentedWords_;
	int shiftedIndex = 0;

	for(unsigned int j = 0; j < fragmentedWords.size(); j++){
		if(fragmentedWords[j].find(";") != std::string::npos){
			semiColonIndex = j;
		}
	}

	try {
		//Check within the vector of strings for keywords to identify day/date, time, deadline, importance
		unsigned int i = 0;
		for (i = semiColonIndex+1; i < fragmentedWords.size(); i++) {
			shiftedIndex = identifyDeadline(i);
			identifyEventName(shiftedIndex);
			shiftedIndex = identifyImportance(i);
			identifyEventName(shiftedIndex);
			shiftedIndex = identifyDay(i);
			identifyEventName(shiftedIndex);
			shiftedIndex = identifyDate(i);
			identifyEventName(shiftedIndex);
			shiftedIndex = identifyTime(i);
			identifyEventName(shiftedIndex);
			matchFound = false;
		}

		if(nameIndex != INVALID_NUMBER){
			tempEventStore.setName(setEventName(nameIndex));
		}
		if(!startDayFound && !startTimeFound && !deadlineFound && !importanceFound && !nameFound && !firstTriggerKeyword){
			nameFound = true;
			logger.logParserIdentified(IDENTIFY_EVENT_NAME);
			nameIndex = fragmentedWords.size()-1;
			tempEventStore.setName(setEventName(nameIndex));
		}

		//Check Exception Cases:
		//Case 1: no event name
		if(tempEventStore.getName() == ""){
			logger.logParserError(ParserExceptions::ERROR_NO_NAME);
			throw ParserExceptions(ParserExceptions::ERROR_NO_NAME);
		}
		//Case 2: name is found. additional input detected after event name but not read in at all
		if (nameFound && !startDayFound && !startTimeFound && !importanceFound) {
			if (fragmentedWords.size() > nameIndex+1) {
				logger.logParserError(ParserExceptions::ERROR_UNUSED_INFORMATION);
				throw ParserExceptions(ParserExceptions::ERROR_UNUSED_INFORMATION);	
			}
		}
		//Case 3: due/deadline keyword found but no date or time input
		if (deadlineFound) {
			if (!endDayFound && !endTimeFound) {
				logger.logParserError(ParserExceptions::ERROR_INSUFFICIENT_INFO);
				throw ParserExceptions(ParserExceptions::ERROR_INSUFFICIENT_INFO);
			}
		}
		//Case 4: some data are unused, means there might be wrong formatting or too many information entered
		for (unsigned int i = nameIndex+1; i < fragmentedWords.size(); i++) {
			try {
				auto tempInt = std::stoi(fragmentedWords[i]);
				logger.logParserError(ParserExceptions::ERROR_UNUSED_INFORMATION);
				throw ParserExceptions(ParserExceptions::ERROR_UNUSED_INFORMATION);
			} catch (...) {
			}
		}
	} catch(ParserExceptions& e) {
		throw e;
	}

	//System-based correction to the input data to complete and confirm the event before returning it
	addEventCorrector();
	eventMktimeCorrector();
	try {
		checkStartBeforeEnd();
	} catch (ParserExceptions& e) {
		throw e;
	}
			
	return tempEventStore;
}

//Process the fragmented vector of strings that contains all the information to be editted by calling further functions to identify any event name, day/date,
//time, deadline and importance of the Event that is to be editted. It then checks what information has been found, and throws exceptions if the basic requirements are not met.
//Lastly, it calls a corrector to correct and confirm the details to be editted in the Event.
//Returns the final completed Event that has extracted and stored all the information to be editted that was initially passed in as a vector.
Event ParserProcessor::processEditEvent(std::vector<std::string> fragmentedWords_) {
	logger.logParserEnterFunc(PROCESS_EDIT_EVENT);

	fragmentedWords = fragmentedWords_;
	int shiftedIndex = 0;

	try {
		//Check if it if changing from normal to floating
		unsigned int i = 0;
		if(identifyNormaltoFloat(i)) {
			i++;
		}

		//Check within the vector of strings for keywords to identify day/date, time, importance
		for (; i < fragmentedWords.size(); i++) {
			shiftedIndex = identifyDeadline(i);
			identifyEventName(shiftedIndex);
			shiftedIndex = identifyImportance(i);
			identifyEventName(shiftedIndex);
			shiftedIndex = identifyDay(i);
			identifyEventName(shiftedIndex);
			shiftedIndex = identifyDate(i);
			identifyEventName(shiftedIndex);
			shiftedIndex = identifyTime(i);
			identifyEventName(shiftedIndex);
			matchFound = false;
		}

		tempEventStore.setName(setEventName(nameIndex));
		if(!startDayFound && !startTimeFound && !deadlineFound && !importanceFound && !firstTriggerKeyword && !normalToFloat){
			nameFound = true;
			logger.logParserIdentified(IDENTIFY_EVENT_NAME);
			nameIndex = fragmentedWords.size()-1;
			tempEventStore.setName(setEventName(nameIndex));
		}

		//Check Exception Cases:
		//Case 1: no name, no day, no time input at all
		if (!nameFound && !startDayFound && !startTimeFound && !importanceFound && !normalToFloat) {
			logger.logParserError(ParserExceptions::ERROR_UNUSED_INFORMATION);
			throw ParserExceptions(ParserExceptions::ERROR_UNUSED_INFORMATION);
		}
		//Case 2: some data are unused, means there might be wrong formatting or too many information entered
		for (unsigned int i = nameIndex+1; i < fragmentedWords.size(); i++) {
			try {
				auto tempInt = std::stoi(fragmentedWords[i]);
				logger.logParserError(ParserExceptions::ERROR_UNUSED_INFORMATION);
				throw ParserExceptions(ParserExceptions::ERROR_UNUSED_INFORMATION);
			} catch (...) {
			}
		}
		//Case 3: cannot convert to deadline events from non deadline
		if (deadlineFound){
			logger.logParserError(ParserExceptions::ERROR_NO_EDIT_TO_DEADLINE);
			throw ParserExceptions(ParserExceptions::ERROR_NO_EDIT_TO_DEADLINE); 
		}

	} catch (ParserExceptions& e) {
		throw e;
	}
	//System-based correction to the input data to confirm the details to be editted in the Event before returning it
	try {
		editEventCorrector();
	} catch (ParserExceptions& e) {
		throw e;
	}

	return tempEventStore;
}

bool ParserProcessor::identifyNormaltoFloat(int index){
	if(fragmentedWords[index] == CONVERT_NORMAL_TO_FLOAT){
		normalToFloat = true;
		tempEventStore.setIsFloating(true);
	}
	return normalToFloat;
}


void ParserProcessor::identifyEventName(int shiftedIndex){
	if(matchFound && !nameFound && !firstTriggerKeyword){
		logger.logParserIdentified(IDENTIFY_EVENT_NAME);
		nameFound = true;
		firstTriggerKeyword = true;
		nameIndex = shiftedIndex;
	}
}

//Sets the name of event to that name if found, removing the ';' at the end. Returns nameFound as true if found.
std::string ParserProcessor::setEventName(int index) {
	std::string tempName = "";
	for(int i = 0; i <= index; i++){
		if(fragmentedWords[i] != LOCKUP_USED_INFORMATION){
			if(i == index){
				if(i == semiColonIndex){
					tempName = tempName + fragmentedWords[i].substr(0,fragmentedWords[i].find_last_not_of(" ;")+1);
				} else {
					tempName = tempName + fragmentedWords[i].substr(0,fragmentedWords[i].find_last_not_of(" ")+1);
				}
			} else {
				tempName = tempName + fragmentedWords[i];
			}
		}
	}
	return tempName;
}


//Checks the string at the current index of the fragmented string vector for the presence of keywords of weekdays/today/tomorrow.
//If found, further operations are done to determine the date set of (day, month and year) based off these keywords.
//The Event's start date and end date will be assigned based on the date set found. Returns matchFound as true if found.
int ParserProcessor::identifyDay(int index) {
	Conversion convertor;
	int tempIndex = index;
	int currentDay = 0, currentWeekDay = 0, inputWeekDay = 0, numWdaysApart = 0;
	std::string strDay;
	std::string lowerCaseString;

	//Find the presence of keywords based on weekdays (tdy,tmr,mon,tues....)
	for (int j = 0; j < NUMBER_OF_KEYWORDS_DAYS && !matchFound; j++) {
		lowerCaseString = fragmentedWords[index];
		for(unsigned int i = 0; i < lowerCaseString.size(); i++){
			lowerCaseString[i] = std::tolower(lowerCaseString[i]);
		}
		if(findExactWord(lowerCaseString,keywordDay[j])){
			strDay = keywordDay[j];
			matchFound = true;
			logger.logParserIdentified(IDENTIFY_DAY);
			tempIndex--;
			
			//assigning start and end date according to what keyword was found
			if (strDay == "today" || strDay == "tdy") {
				if (!startDayFound) {
					tempEventStore.setStartDate(now->tm_mday,now->tm_mon,now->tm_year);
					startDayFound = true;
				} else if (!endDayFound) {
					tempEventStore.setEndDate(now->tm_mday,now->tm_mon,now->tm_year);
					endDayFound = true;
				} else {
					logger.logParserError(ParserExceptions::ERROR_TOO_MANY_DATES);
					throw ParserExceptions(ParserExceptions::ERROR_TOO_MANY_DATES);
				}
			} else if (strDay == "tomorrow" || strDay == "tmr") {
				if (!startDayFound) {
					tempEventStore.setStartDate(now->tm_mday+1,now->tm_mon,now->tm_year);
					startDayFound = true;
				} else if (!endDayFound) {
					tempEventStore.setEndDate(now->tm_mday+1,now->tm_mon,now->tm_year);
					endDayFound = true;
				} else {
					logger.logParserError(ParserExceptions::ERROR_TOO_MANY_DATES);
					throw ParserExceptions(ParserExceptions::ERROR_TOO_MANY_DATES);
				}
			} else {
				currentWeekDay = now->tm_wday;
				inputWeekDay = convertor.dayOfWeekToInt(strDay);
				//finding number of days from current day to the input week day
				if (inputWeekDay > currentWeekDay) {
					numWdaysApart = inputWeekDay - currentWeekDay;
				} else if (inputWeekDay <= currentWeekDay) {
					numWdaysApart = inputWeekDay - (currentWeekDay - NUMBER_OF_DAYSINAWEEK);
				}
				//checking for next which will add one extra week
				if (tempIndex >= 0) {
					lowerCaseString = fragmentedWords[tempIndex];
					for(unsigned int i = 0; i < lowerCaseString.size(); i++){
						lowerCaseString[i] = std::tolower(lowerCaseString[i]);
					}
					if ((findExactWord(lowerCaseString,"next")) || (findExactWord(lowerCaseString,"nxt"))) {
						numWdaysApart = numWdaysApart + NUMBER_OF_DAYSINAWEEK;
						tempIndex--;
					}
				}
				if (!startDayFound) {
					startDayFound = true;
					tempEventStore.setStartDate(now->tm_mday+numWdaysApart,now->tm_mon,now->tm_year);
				} else if (!endDayFound) {
					endDayFound = true;
					tempEventStore.setEndDate(now->tm_mday+numWdaysApart,now->tm_mon,now->tm_year);
				} else {
					logger.logParserError(ParserExceptions::ERROR_TOO_MANY_DATES);
					throw ParserExceptions(ParserExceptions::ERROR_TOO_MANY_DATES);
				}
			}
		}
	}
	if(tempIndex < 0){
		tempIndex = INVALID_NUMBER;
	}
	return tempIndex;
}

//Checks the string at the current index of the fragmented string vector for the presence of any keywords of months. 
//If found, further operations are performed to extract the day, month and year from the surrounding strings in the vector to complete a date set.
//A date set will consist of (day, month, year). The Event's start date and end date will be assigned based on the date set found.
//Returns matchFound is true if a date is found.
int ParserProcessor::identifyDate(int index) {
	Conversion convertor;
	int indexShift = 0, tempIndex = index;
	int tempInt = 0, day = 0, month = 0, year = 0, dayTo = 0;
	std::string strMonth;
	std::string lowerCaseString;
	
	//finding the keywords of months within the current string in the fragmented string vector 
	for (int j = 0; j < NUMBER_OF_KEYWORDS_MONTHS && !matchFound; j++) {
		lowerCaseString = fragmentedWords[index];
		for(unsigned int i = 0; i < lowerCaseString.size(); i++){
			lowerCaseString[i] = std::tolower(lowerCaseString[i]);
		}
		if (findExactWord(lowerCaseString,keywordMonths[j])){
			strMonth = keywordMonths[j];
			matchFound = true;
			logger.logParserIdentified(IDENTIFY_DATE);
			
			//Retrieving one set of (day, month, year) from input data
			year = checkYear(tempIndex,&indexShift);
			tempIndex += indexShift;
			day = checkDay(tempIndex,&indexShift);
			tempIndex += indexShift;
			month = convertor.monthToInt(strMonth);

			//Confirming first set of (day, month, year)
			if ((day > convertor.determineLastDayOfMth(month,year)) || (day == 0)) {
				logger.logParserError(ParserExceptions::ERROR_UNKNOWN_DATE);
				throw ParserExceptions(ParserExceptions::ERROR_UNKNOWN_DATE);
			}
			
			//Retrieve second set of (day, month, year) if 'to' is found, using previous month and year
			dayTo = checkDayTo(tempIndex,&indexShift);
			tempIndex += indexShift;

			//Confirming second set of (day, month, year)
			if ((day > convertor.determineLastDayOfMth(month,year)) || (day == 0)) {
				logger.logParserError(ParserExceptions::ERROR_UNKNOWN_DATE);
				throw ParserExceptions(ParserExceptions::ERROR_UNKNOWN_DATE);
			}

			//Assigning the values retrieved into start day or end day of event
			assignDate(day,month,year,dayTo);
		}
	}
	if(tempIndex < 0){
		tempIndex = INVALID_NUMBER;
	}
	return tempIndex;
}

//Checking for and extracting year integer. If not found, current year is used instead.
//Returns the value of year in int form in the format used in tm struct.
int ParserProcessor::checkYear(int tempIndex, int* indexShift) {			
	int year = now->tm_year;
	*indexShift = tempIndex;
	int tempInt = 0;

	if (tempIndex + 1 < fragmentedWords.size()) {
		try {
			auto tempStoi = std::stoi(fragmentedWords[tempIndex+1]);
			tempInt = tempStoi;
			if(tempInt > POSSIBLE_YEAR_INTEGER){
				if (tempInt > LOWER_RANGE_YEAR && tempInt < HIGHER_RANGE_YEAR) {
					year = tempInt - TM_YEAR_ADJUSTMENT;
					fragmentedWords[tempIndex+1] = LOCKUP_USED_INFORMATION;
				} else {
					throw ParserExceptions(ParserExceptions::ERROR_INVALID_YEAR);
				}
			}
		} catch (...) {
		}
	}
	*indexShift = tempIndex - *indexShift;
	return year;
}

//Extracting the day integer, either in the same string as the keyword or in the string before the keyword.
//Return the day as an int if found. Throws exception if no day is found.
int ParserProcessor::checkDay(int tempIndex, int* indexShift) {
	Conversion convertor;
	int tempInt = 0;
	*indexShift = tempIndex;
	
	tempIndex--;
	if (tempIndex >= 0) {
		try {
			auto tempStoi = std::stoi(fragmentedWords[tempIndex]);
			fragmentedWords[tempIndex] = LOCKUP_USED_INFORMATION;
			tempInt = tempStoi;
		} catch (...) {
			tempInt = INVALID_NUMBER;
		}
	}
	*indexShift = tempIndex - *indexShift;
	return tempInt;
}

//Checks for 'to' word before a date set. 'to' indicates that the day input before 'to' uses the same month value as the day input after the 'to'.
//Function sets toFound to true if a day before the word 'to' is found. It returns the day if found, or returns 0 if not found. 
int ParserProcessor::checkDayTo(int tempIndex, int* indexShift) {
	int tempInt = 0;
	*indexShift = tempIndex; 

	tempIndex--;
	if (tempIndex >= 0) {
		if (fragmentedWords[tempIndex] == "to" || fragmentedWords[tempIndex] == "to " ) {
			tempIndex--;
			if (tempIndex >= 0) {
				try {
					auto tempStoi = std::stoi(fragmentedWords[tempIndex]);
					fragmentedWords[tempIndex] = LOCKUP_USED_INFORMATION;
					tempInt = tempStoi;
					toFound = true;
					logger.logParserIdentified(IDENTIFY_DATE);
					tempIndex--;
				} catch (...) {
					tempInt = INVALID_NUMBER;
				}
			}
		}
	}
	*indexShift = tempIndex - *indexShift;
	return tempInt;
}

//Inserts the Start day and End day into the temporary Event based on the day, month and year that was found.
//Takes into account whether start day and end day have already been found, and assign accordingly. Throws exception if there are too many dates.
void ParserProcessor::assignDate(int day, int month, int year, int dayTo) {
	if (toFound && dayTo != INVALID_NUMBER) {
		if (!startDayFound && !endDayFound) {
			startDayFound = true;
			tempEventStore.setStartDate(dayTo,month,year);
			endDayFound = true;
			tempEventStore.setEndDate(day,month,year);
			toFound = false;
		} else if (tempEventStore.getIsDeadline()) {
			logger.logParserError(ParserExceptions::ERROR_DUE_TOO_MANY_DATES);
			throw ParserExceptions(ParserExceptions::ERROR_DUE_TOO_MANY_DATES);
		} else {
			logger.logParserError(ParserExceptions::ERROR_TOO_MANY_DATES);
			throw ParserExceptions(ParserExceptions::ERROR_TOO_MANY_DATES);
		}
	} else if (day != INVALID_NUMBER){
		if (!startDayFound) {
			startDayFound = true;
			tempEventStore.setStartDate(day,month,year);
		} else if (!endDayFound) {
			endDayFound = true;
			tempEventStore.setEndDate(day,month,year);
		} else if (tempEventStore.getIsDeadline()) {
			logger.logParserError(ParserExceptions::ERROR_DUE_TOO_MANY_DATES);
			throw ParserExceptions(ParserExceptions::ERROR_DUE_TOO_MANY_DATES);
		} else {
			logger.logParserError(ParserExceptions::ERROR_TOO_MANY_DATES);
			throw ParserExceptions(ParserExceptions::ERROR_TOO_MANY_DATES);
		}
	} else {
		matchFound = false;
	}
}

//Checks the string at the current index of the fragmented string vector for the presence of any keywords of time. 
//If found, further operations are performed to extract the hour and minutes from the surrounding strings in the vector to complete a time set.
//A time set will consist of (hour, minute). The Event's start time and end time will be assigned based on the time set found.
//Returns matchFound is true if a time is found.
int ParserProcessor::identifyTime(int index) {

	int tempIndex = index, firstTimeInteger = 0, indexShift = 0;
	timeSet hourMin;
	timeSet toHourMin;
	hourMin.hour = 0; hourMin.minute = 0;
	toHourMin.hour = 0; toHourMin.minute = 0;
	std::string lowerCaseString;
	
	//finding the keywords of time within the current string in the fragmented string vector
	for (int j = 0; j < NUMBER_OF_KEYWORDS_TIME && !matchFound; j++) {
		lowerCaseString = fragmentedWords[index];
		for(unsigned int i = 0; i < lowerCaseString.size(); i++){
			lowerCaseString[i] = std::tolower(lowerCaseString[i]);
		}
		if (findExactWord(lowerCaseString,keywordTime[j])){
			if (keywordTime[j] == "pm") {
				afterTwelve = true;
			}
			matchFound = true;
			logger.logParserIdentified(IDENTIFY_TIME);

			//Retrieving one time set of (hour, minute) from the input data
			firstTimeInteger = extractFirstTimeInteger(tempIndex,&indexShift);
			tempIndex += indexShift;
			hourMin = extractHourMin(tempIndex,firstTimeInteger,&indexShift);
			tempIndex += indexShift;

			//Retrieve second time set of (hour, minute) if 'to' is found, using previous am/pm
			toHourMin = extractHourMinTo(tempIndex,&indexShift);
			tempIndex += indexShift;
			
			//Assigning the values retrieved into start time or end time of event
			assignTime(hourMin,toHourMin);
			
			afterTwelve = false;
		}
	}
	if(tempIndex < 0){
		tempIndex = INVALID_NUMBER;
	}
	return tempIndex;
}

//Extracting first integer found either in the same string as the keyword or a string before the keyword
//Returns the value of the first integer found. Throws exception if no integer is found.
int ParserProcessor::extractFirstTimeInteger(int tempIndex, int* indexShift) {
	int firstTimeInteger = 0;
	*indexShift = tempIndex; 

	tempIndex--;
	if (tempIndex >= 0) {
		std::string tempTimeString = fragmentedWords[tempIndex];
		if(tempTimeString.find(".") != std::string::npos){
			tempTimeString = tempTimeString.substr(0,tempTimeString.find(".")) + tempTimeString.substr(tempTimeString.find(".")+1);
		}
		try {
			auto tempStoi = std::stoi(tempTimeString);
			fragmentedWords[tempIndex] = LOCKUP_USED_INFORMATION;
			firstTimeInteger = tempStoi;
		} catch (...) {
			firstTimeInteger = INVALID_NUMBER;
		}
	} 
	*indexShift = tempIndex - *indexShift;
	return firstTimeInteger;
}
			
//Extracting and registering a time set of (hour, minute) based on the first integer found. 
//Throws exception if the hour or minutes are invalid and unknown. Returns a time set in struct timeSet form containing hour & minute.
ParserProcessor::timeSet ParserProcessor::extractHourMin(int tempIndex, int firstTimeInteger, int* indexShift) {
	ParserProcessor::timeSet hourMin;
	int hour = 0, minute = 0;
	*indexShift = tempIndex; 

	if (firstTimeInteger >= 100) {  //For time input in the form of combined hour & minute. E.g. 930 1045 1230
		tempIndex--;
		minute = firstTimeInteger%100;
		if (minute > MAX_MINUTE) {
			logger.logParserError(ParserExceptions::ERROR_UNKNOWN_MINUTE);
			throw ParserExceptions(ParserExceptions::ERROR_UNKNOWN_MINUTE);
		}
		hour = firstTimeInteger/100;
		if (hour > MAX_HOUR) {
			logger.logParserError(ParserExceptions::ERROR_UNKNOWN_HOUR);
			throw ParserExceptions(ParserExceptions::ERROR_UNKNOWN_HOUR);
		}
		if (afterTwelve) {
			if (hour < MORNING_TIME) {
				hour = hour + MORNING_AFTERNOON_DIFFERENTIAL;
			}
		} else {
			if (hour == MORNING_TIME) {
				hour = MIDNIGHT_TIME;
			}
		}
	} else if (firstTimeInteger < 100) {  //For time input with hour only
		tempIndex--;
		hour = firstTimeInteger;
		minute = 0;
		if (minute > MAX_MINUTE) {
			logger.logParserError(ParserExceptions::ERROR_UNKNOWN_MINUTE);
			throw ParserExceptions(ParserExceptions::ERROR_UNKNOWN_MINUTE);
		}
		if (hour > MAX_HOUR) {
			logger.logParserError(ParserExceptions::ERROR_UNKNOWN_HOUR);
			throw ParserExceptions(ParserExceptions::ERROR_UNKNOWN_HOUR);
		}
		if (afterTwelve) {
			if (hour < MORNING_TIME) {
				hour = hour + MORNING_AFTERNOON_DIFFERENTIAL;
			}
		} else {
			if (hour == MORNING_TIME) {
				hour = MIDNIGHT_TIME;
			}
		}
	}
	hourMin.hour = hour;
	hourMin.minute = minute;
	*indexShift = tempIndex - *indexShift;
	return hourMin;
}
			
//Checks for 'to' word before a time set. 'to' indicates that the hour and minute input before 'to' uses the same am/pm value as the hour and minute input after the 'to'.
//Function sets toFound to true if a time set before the word 'to' is found. Throws exceptions if the hour and minute input are invalid or unknown.
//It returns the time set if found, or returns a zero-ed time set if not found. 
ParserProcessor::timeSet ParserProcessor::extractHourMinTo(int tempIndex, int* indexShift) {
	ParserProcessor::timeSet toHourMin;
	int tempInt = 0;
	int toHour = 0, toMinute = 0;
	*indexShift = tempIndex;

	if (tempIndex >= 0) {
		if (fragmentedWords[tempIndex] == "to" || fragmentedWords[tempIndex] == "to " ) {
			tempIndex--;
			if (tempIndex >= 0) {
				std::string tempTimeString = fragmentedWords[tempIndex];
				if(tempTimeString.find(".") != std::string::npos){
					tempTimeString = tempTimeString.substr(0,tempTimeString.find(".")) + tempTimeString.substr(tempTimeString.find(".")+1);
				}
				try {
					auto tempStoi = std::stoi(tempTimeString);
					fragmentedWords[tempIndex] = LOCKUP_USED_INFORMATION;
					tempInt = tempStoi;
					toFound = true;
					logger.logParserIdentified(IDENTIFY_TIME);

					if (tempInt >= 100) {   //For time input in the form of combined hour & minute. E.g. 930 1045 1230
						toMinute = tempInt%100;
						if (toMinute > MAX_MINUTE) {
							logger.logParserError(ParserExceptions::ERROR_UNKNOWN_MINUTE);
							throw ParserExceptions(ParserExceptions::ERROR_UNKNOWN_MINUTE);
						}
						toHour = tempInt/100;
						if (toHour > MAX_HOUR) {
							logger.logParserError(ParserExceptions::ERROR_UNKNOWN_HOUR);
							throw ParserExceptions(ParserExceptions::ERROR_UNKNOWN_HOUR);
						}
						if (afterTwelve) {
							if (toHour < MORNING_TIME) {
								toHour = toHour + MORNING_AFTERNOON_DIFFERENTIAL;
							}
						} else {
							if (toHour == MORNING_TIME) {
								toHour = MIDNIGHT_TIME;
							}
						}
					} else if (tempInt < 100) {   //For time input with hour only
						toHour = tempInt;
						toMinute = 0;
						if (toMinute > MAX_MINUTE) {
							logger.logParserError(ParserExceptions::ERROR_UNKNOWN_MINUTE);
							throw ParserExceptions(ParserExceptions::ERROR_UNKNOWN_MINUTE);
						}
						if (toHour > MAX_HOUR) {
							logger.logParserError(ParserExceptions::ERROR_UNKNOWN_HOUR);
							throw ParserExceptions(ParserExceptions::ERROR_UNKNOWN_HOUR);
						}
						if (afterTwelve) {
							if (toHour < MORNING_TIME) {
								toHour = toHour + MORNING_AFTERNOON_DIFFERENTIAL;
							}
						} else {
							if (toHour == MORNING_TIME) {
								toHour = MIDNIGHT_TIME;
							}
						}
					}
					tempIndex--;
				} catch (...) {
					toHour = INVALID_NUMBER;
					toMinute = INVALID_NUMBER;
				}
			}
		}
	}
	toHourMin.hour = toHour;
	toHourMin.minute = toMinute;
	*indexShift = tempIndex - *indexShift;
	return toHourMin;
}

//Inserts the Start time and End time into the temporary Event based on the timeSet retrieved from the data.
//Takes into account whether start time and end time have already been found, and assign accordingly. Throws exception if there are too many times.
void ParserProcessor::assignTime(ParserProcessor::timeSet hourMin, ParserProcessor::timeSet toHourMin) {
	if (toFound && toHourMin.hour != INVALID_NUMBER && toHourMin.minute != INVALID_NUMBER) {
		if (!startTimeFound && !endTimeFound) {
			startTimeFound = true;
			tempEventStore.setStartTime(toHourMin.hour,toHourMin.minute);
			endTimeFound = true;
			tempEventStore.setEndTime(hourMin.hour,hourMin.minute);
			toFound = false;
		} else if (tempEventStore.getIsDeadline()) {
			logger.logParserError(ParserExceptions::ERROR_DUE_TOO_MANY_TIMES);
			throw ParserExceptions(ParserExceptions::ERROR_DUE_TOO_MANY_TIMES);
		} else {
			logger.logParserError(ParserExceptions::ERROR_TOO_MANY_TIMES);
			throw ParserExceptions(ParserExceptions::ERROR_TOO_MANY_TIMES);
		}
	} else if(hourMin.hour != INVALID_NUMBER && hourMin.minute != INVALID_NUMBER){
		if (endDayFound && !deadlineFound){
			if (!startTimeFound && endTimeFound){
				struct tm tempTime = tempEventStore.getEndDate();
				tempEventStore.setStartTime(tempTime.tm_hour,tempTime.tm_min);
				startTimeFound = true;
				tempEventStore.setEndTime(hourMin.hour,hourMin.minute);
			} else if(!startTimeFound){
				tempEventStore.setEndTime(hourMin.hour,hourMin.minute);
				endTimeFound = true;
			} else if(startTimeFound && !endTimeFound){
				endTimeFound = true;
				tempEventStore.setEndTime(hourMin.hour,hourMin.minute);
			} else if(startTimeFound && endTimeFound){
				logger.logParserError(ParserExceptions::ERROR_TOO_MANY_TIMES);
				throw ParserExceptions(ParserExceptions::ERROR_TOO_MANY_TIMES);
			}
		} else {
			if (!startTimeFound) {
				startTimeFound = true;
				tempEventStore.setStartTime(hourMin.hour,hourMin.minute);
			} else if (!endTimeFound) {				
				endTimeFound = true;
				tempEventStore.setEndTime(hourMin.hour,hourMin.minute);
			} else if (tempEventStore.getIsDeadline()) {
				logger.logParserError(ParserExceptions::ERROR_DUE_TOO_MANY_TIMES);
				throw ParserExceptions(ParserExceptions::ERROR_DUE_TOO_MANY_TIMES);
			} else {
				logger.logParserError(ParserExceptions::ERROR_TOO_MANY_TIMES);
				throw ParserExceptions(ParserExceptions::ERROR_TOO_MANY_TIMES);
			}
		}
	} else {
		matchFound = false;
	}
}

//Checks the string at the current index of the fragmented string vector for the keyword "due" or "by", indicating a deadline event.
//Sets the temporary Event isDeadline to true, and toggles the startDayFound and startTimeFound to true to prevent more than 2 day & time input. 
//Returns matchFound as true if found. 
int ParserProcessor::identifyDeadline(int index) {
	int tempIndex = index;
	std::string lowerCaseString;
	lowerCaseString = fragmentedWords[index];
	for(unsigned int i = 0; i < lowerCaseString.size() && !deadlineFound; i++){
		lowerCaseString[i] = std::tolower(lowerCaseString[i]);
	}
	if (findExactWord(lowerCaseString,"due") || findExactWord(lowerCaseString,"by")) {
		tempEventStore.setIsDeadline(true);
		deadlineFound = true;
		logger.logParserIdentified(IDENTIFY_DEADLINE);
		if (!endDayFound) {
			endDayFound = true;
		} else {
			throw ParserExceptions(ParserExceptions::ERROR_DUE_TOO_MANY_DATES);
		}
		if (!endTimeFound) {
			endTimeFound = true;
		} else {
			throw ParserExceptions(ParserExceptions::ERROR_DUE_TOO_MANY_TIMES);
		}
		matchFound = true;
		tempIndex--;
	}
	if(tempIndex < 0){
		tempIndex = INVALID_NUMBER;
	}
	return tempIndex;
}

//Checks the string at the current index of the fragmented string vector for the presence of a '!' to indicate importance.
//Determine the level of importance and sets the temporary Event importance level. Throws exception if importance is of wrong format.
//Returns matchFound as true if found.
int ParserProcessor::identifyImportance(int index) {
	int tempIndex = index;
	std::string tempStr = fragmentedWords[index];
	int levelImportance = 0;
	if(!tempStr.empty()){
		if (tempStr.at(0) == '!') {
			matchFound = true;
			for (unsigned int i = 0; i < tempStr.size(); i++) {
				if (tempStr.at(i) == '!') {
					levelImportance++;
				} else if(i != tempStr.size()-1){
					matchFound = false;
				}
			}
			if(matchFound){
				tempIndex--;
				importanceFound = true;
				logger.logParserIdentified(IDENTIFY_IMPORTANCE);
				tempEventStore.setImportanceLevel(levelImportance);
			}
		}
	}
	if(tempIndex < 0){
		tempIndex = INVALID_NUMBER;
	}
	return tempIndex;
}

//Function corrects missing/wrong start day, end day, start time and end time in the temporary Event based on 
//what type of Event it has been identified as.
void ParserProcessor::addEventCorrector() {
	logger.logParserEnterFunc(ADD_EVENT_CORRECTOR);

	//Deadline events, set Start date and Start time to be equal to the End date and End time read from input
	if (tempEventStore.getIsDeadline()) {
		struct tm tempTime = tempEventStore.getStartDate();
		if (startDayFound && startTimeFound) {
			tempEventStore.setEndDate(tempTime.tm_mday,tempTime.tm_mon,tempTime.tm_year);
			tempEventStore.setEndTime(tempTime.tm_hour,tempTime.tm_min);
		}
		if (startDayFound && !startTimeFound) {
			tempEventStore.setStartTime(23,59);
			tempEventStore.setEndTime(23,59);
			tempEventStore.setEndDate(tempTime.tm_mday,tempTime.tm_mon,tempTime.tm_year);
			startTimeFound = true;
		}
		if (!startDayFound && startTimeFound) {
			tempEventStore.setStartDate(now->tm_mday,now->tm_mon,now->tm_year);
			tempEventStore.setEndDate(now->tm_mday,now->tm_mon,now->tm_year);
			tempEventStore.setEndTime(tempTime.tm_hour,tempTime.tm_min);
			startDayFound = true;
		}
	} else {
		//Floating events, set temporary Event isFloating to true
		if (!startDayFound && !startTimeFound) {
			tempEventStore.setIsFloating(true);
		}
		//Full day events, set Start time to 0am and End time to 11.59pm
		if (startDayFound && !startTimeFound && !endTimeFound) {
			tempEventStore.setStartTime(0,0);
			tempEventStore.setEndTime(23,59);
		}
		//Today event, set Start day and End day to the current system day
		if (!startDayFound && startTimeFound) {
			int day = now->tm_mday; 
			int month = now->tm_mon; 
			int year = now->tm_year;
			tempEventStore.setStartDate(day,month,year);
			tempEventStore.setEndDate(day,month,year);
		}
		//Single day event, set End day to be equal to the Start day
		if (!endDayFound) {
			struct tm tempTime = tempEventStore.getStartDate();
			tempEventStore.setEndDate(tempTime.tm_mday,tempTime.tm_mon,tempTime.tm_year);
		}
		//Event with Start time only, sets End time to an hour after Start time by default
		if (!endDayFound && startTimeFound && !endTimeFound) {
			struct tm tempTime = tempEventStore.getStartDate();
			if ((tempTime.tm_hour)+1 == 24 && tempTime.tm_min == 0) {   //Corrects any 12am timing to 11.59pm to prevent spilling over to next day
				tempEventStore.setEndTime(23,59);					  //Because day ends at 11.59pm and new day starts at 12am
			} else {
				tempEventStore.setEndTime((tempTime.tm_hour)+1,tempTime.tm_min);
			}
			endTimeFound = true;
		}
		//Multiple day events with End time only, sets Start time to 12am of the first day
		if (endDayFound && startTimeFound && !endTimeFound){
			tempEventStore.setEndTime(23,59);
			endTimeFound = true;
		}
		//Multiple day events with End time only, sets Start time to 12am of the first day
		if (endDayFound && endTimeFound && !startTimeFound) {
			tempEventStore.setStartTime(0,0);
			startTimeFound = true;
		}
		//Corrects any 12am timing to 11.59pm to prevent spilling over to next day, because day ends at 11.59pm and new day starts at 12am
		if (startTimeFound && endTimeFound) {
			struct tm tempTime = tempEventStore.getEndDate();
			if (tempTime.tm_hour == 0 && tempTime.tm_min == 0) {
				tempEventStore.setEndTime(23,59);
			}
		}
		//Corrects any spill over timing mistake of the user input to update the End day to the next day. E.g. tdy 10pm-3am -> tdy to tmr 10pm-3am
		struct tm tempEventStartDate = tempEventStore.getStartDate();
		struct tm tempEventEndDate = tempEventStore.getEndDate();
		if (tempEventStartDate.tm_mday == tempEventEndDate.tm_mday &&
			tempEventStartDate.tm_mon == tempEventEndDate.tm_mon &&
			tempEventStartDate.tm_year == tempEventEndDate.tm_year) {
				if (tempEventEndDate.tm_hour < tempEventStartDate.tm_hour) {
					tempEventStore.setEndDate(tempEventStartDate.tm_mday+1,tempEventStartDate.tm_mon,tempEventStartDate.tm_year);
				} else if (tempEventEndDate.tm_hour == tempEventStartDate.tm_hour && tempEventEndDate.tm_min < tempEventStartDate.tm_min) {
					tempEventStore.setEndDate(tempEventStartDate.tm_mday+1,tempEventStartDate.tm_mon,tempEventStartDate.tm_year);
				}
		}
	}
}

void ParserProcessor::checkStartBeforeEnd() {
	struct tm tempEventStartDate = tempEventStore.getStartDate();
	struct tm tempEventEndDate = tempEventStore.getEndDate();
	
	//Exception case 1: Start day is later than End day
	if (tempEventStartDate.tm_year > tempEventEndDate.tm_year) {
		throw ParserExceptions(ParserExceptions::ERROR_START_AFTER_END);
	} 
	if (tempEventStartDate.tm_year == tempEventEndDate.tm_year) {
		if (tempEventStartDate.tm_mon > tempEventEndDate.tm_mon) {
			throw ParserExceptions(ParserExceptions::ERROR_START_AFTER_END);
		}
	}
	if (tempEventStartDate.tm_year == tempEventEndDate.tm_year) {
		if (tempEventStartDate.tm_mon == tempEventEndDate.tm_mon) {
			if (tempEventStartDate.tm_mday > tempEventEndDate.tm_mday) {
				throw ParserExceptions(ParserExceptions::ERROR_START_AFTER_END);
			}
		}
	}

	//Exception case 2: Start time is later than End time if day is the same
	if (tempEventStartDate.tm_year == tempEventEndDate.tm_year &&
		tempEventStartDate.tm_mon == tempEventEndDate.tm_mon &&
		tempEventStartDate.tm_mday == tempEventEndDate.tm_mday) {
			if (tempEventStartDate.tm_hour > tempEventEndDate.tm_hour) {
				throw ParserExceptions(ParserExceptions::ERROR_START_AFTER_END);
			} 
			if (tempEventStartDate.tm_hour == tempEventEndDate.tm_hour) {
				if (tempEventStartDate.tm_min > tempEventEndDate.tm_min) {
					throw ParserExceptions(ParserExceptions::ERROR_START_AFTER_END);
				}
			}
	}
}

//Function ensures only the details entered in the input will be editted while the other data will be left untouched by creating dummy values 
//to signal which detail should not be touched. Performs correction to the details that are to be editted, by completing and correcting their values.
void ParserProcessor::editEventCorrector() {
	logger.logParserEnterFunc(EDIT_EVENT_CORRECTOR);

	//Single day event, set End day to be equal to Start day
	if (startDayFound && !endDayFound) {
		struct tm tempTime = tempEventStore.getStartDate();
		tempEventStore.setEndDate(tempTime.tm_mday,tempTime.tm_mon,tempTime.tm_year);
	}
	//Event with Start time only, sets End time to an hour after Start time by default
	if (startTimeFound && !endDayFound && !endTimeFound) {
		struct tm tempTime = tempEventStore.getStartDate();
		if (tempTime.tm_hour+1 == 24 && tempTime.tm_min == 0) {
			tempEventStore.setEndTime(23,59);
		} else {
			tempEventStore.setEndTime((tempTime.tm_hour)+1,tempTime.tm_min);
		}
	}
	//Multiple day events with End time only, sets Start time to 12am of the first day
	if (endDayFound && startTimeFound && !endTimeFound){
		tempEventStore.setEndTime(23,59);
		endTimeFound = true;
	}
	//Multiple day events with End time only, sets Start time to 12am of the first day
	if (endDayFound && endTimeFound && !startTimeFound) {
		tempEventStore.setStartTime(0,0);
		startTimeFound = true;
	}
	//Corrects any spill over timing mistake of the user input to update the End day to the next day. E.g. 10pm-3am -> tdy to tmr 10pm-3am
	struct tm tempEventStartDate = tempEventStore.getStartDate();
	struct tm tempEventEndDate = tempEventStore.getEndDate();
	if (tempEventStartDate.tm_mday == tempEventEndDate.tm_mday &&
		tempEventStartDate.tm_mon == tempEventEndDate.tm_mon &&
		tempEventStartDate.tm_year == tempEventEndDate.tm_year) {
			if (tempEventEndDate.tm_hour < tempEventStartDate.tm_hour) {
				tempEventStore.setEndDate(tempEventStartDate.tm_mday+1,tempEventStartDate.tm_mon,tempEventStartDate.tm_year);
			} else if (tempEventEndDate.tm_hour == tempEventStartDate.tm_hour && tempEventEndDate.tm_min < tempEventStartDate.tm_min) {
				tempEventStore.setEndDate(tempEventStartDate.tm_mday+1,tempEventStartDate.tm_mon,tempEventStartDate.tm_year);
			}
	}
	
	//Only calls correctors after Start day/Start time/End day/End time has been completed
	if (startDayFound || startTimeFound) {
		try {
			checkStartBeforeEnd();
		} catch (ParserExceptions& e) {
			throw e;
		}
	}
	eventMktimeCorrector();

	//Set dummy values to details that should not be touched
	if (!nameFound) {
		tempEventStore.setName("");
	}
	if (!startDayFound) {
		tempEventStore.setStartDate(DO_NOT_TOUCH,DO_NOT_TOUCH,DO_NOT_TOUCH);
		tempEventStore.setEndDate(DO_NOT_TOUCH,DO_NOT_TOUCH,DO_NOT_TOUCH);
	}
	if (!startTimeFound) {
		tempEventStore.setStartTime(DO_NOT_TOUCH,DO_NOT_TOUCH);
		tempEventStore.setEndTime(DO_NOT_TOUCH,DO_NOT_TOUCH);
	}
	if (!importanceFound) {
		tempEventStore.setImportanceLevel(-1);
	}
}

//Performs mktime on both the Start date as well as the End date of the temporary Event to ensure a correct (day, month, year) and also
//to generate the weekday value for the Start date.
void ParserProcessor::eventMktimeCorrector() {
	logger.logParserEnterFunc(EVENT_MK_TIME_CORRECTOR);

	struct tm* temptmPtr;
	temptmPtr = &tempEventStore.getStartDate();
	mktime(temptmPtr);
	tempEventStore.setStartDate(temptmPtr->tm_mday,temptmPtr->tm_mon,temptmPtr->tm_year);
	tempEventStore.setStartTime(temptmPtr->tm_hour,temptmPtr->tm_min);
	tempEventStore.setStartWeekday(temptmPtr->tm_wday);

	temptmPtr = &tempEventStore.getEndDate();
	mktime(temptmPtr);
	tempEventStore.setEndDate(temptmPtr->tm_mday,temptmPtr->tm_mon,temptmPtr->tm_year);
	tempEventStore.setEndTime(temptmPtr->tm_hour,temptmPtr->tm_min);
	tempEventStore.setEndWeekday(temptmPtr->tm_wday);
}

//Process the fragmented vector of strings that contains to be shown by calling further functions to identify day/date. It then checks what information has been found, and throws 
//exceptions if the basic requirements are not met. Lastly, it calls a corrector to correct the date set to a valid date.
//Returns an Event that contains the range of days to be shown from its Start day to its End day.
Event ParserProcessor::processShowEvent(std::vector<std::string> fragmentedWords_) {
	logger.logParserEnterFunc(PROCESS_SHOW_EVENT);

	std::string tempString;
	fragmentedWords = fragmentedWords_;
	int tempInt = 0;
	int daysToEndWeek = 0, weekday = 0;
	int day = now->tm_mday;
	int month = now->tm_mon;
	int year = now->tm_year;

	unsigned int i = 0; 
	//Check for show by year. E.g. show year/yr   show 2015   show 2015-2016
	if (i < fragmentedWords.size()) {
		if (checkShowByYear(i)) {
			i++;
		}
	}

	//Check for system based Show. E.g. week/wk, month/mth, float, due, importance, all)
	if (i < fragmentedWords.size()) {
		if (checkSystemBasedShow(i)) {
			i++;
		}
	}

	//Check for user based Show (e.g. 14 apr, april, month/ april, week/ 14apr, 17 apr to 18 apr, apr to may)
	for (; i < fragmentedWords.size(); i++) {
		identifyShowDay(i);
		identifyShowDate(i);
		matchFound = false;
	}

	//Exception Cases:
	//Case 1: no show is found
	if (!systemShowOthers && !systemShowYear && !userShowDay && !userShowMonth && !userShowRangeOfDays && !userShowRangeOfMonths && !systemShowWeek && !systemShowMonth) {
		logger.logParserError(ParserExceptions::ERROR_NO_SHOW);
		throw ParserExceptions(ParserExceptions::ERROR_NO_SHOW);
	}

	//Case 2: some data are unused, means there might be wrong formatting or too many information entered
	for (unsigned int i = 0; i < fragmentedWords.size(); i++) {
		try {
			auto tempInt = std::stoi(fragmentedWords[i]);
			logger.logParserError(ParserExceptions::ERROR_UNUSED_INFORMATION);
			throw ParserExceptions(ParserExceptions::ERROR_UNUSED_INFORMATION);
		} catch (...) {
		}
	}

	//Correcting dates
	showEventCorrector();
	if (!systemShowOthers) {
		try {
			checkStartBeforeEnd();
		} catch (ParserExceptions& e) {
			throw e;
		}
	}
	eventMktimeCorrector();

	return tempEventStore;
}

//Verifies if the first word is a show by year and assigns Start and End date accordingly.  
//Returns true if the a show by year is identified.
bool ParserProcessor::checkShowByYear(int tempIndex) {
	int tempInt = 0;
	int day = now->tm_mday;
	int month = now->tm_mon;
	int year = now->tm_year;
	bool nextFound = false;
	std::string firstWord = fragmentedWords[tempIndex];

	try {      //Check if first word is a year integer. E.g. 2015
		auto tempStoi = std::stoi(firstWord);
		tempInt = tempStoi;
		if(tempInt > POSSIBLE_YEAR_INTEGER){
			if (tempInt > LOWER_RANGE_YEAR && tempInt < HIGHER_RANGE_YEAR) {
				if (year == tempInt - TM_YEAR_ADJUSTMENT) {
					tempEventStore.setStartDate(day,month,year);
					tempEventStore.setEndDate(31,11,year);
				} else {
					year = tempInt - TM_YEAR_ADJUSTMENT;
					tempEventStore.setStartDate(1,0,year);
					tempEventStore.setEndDate(31,11,year);
				}
				systemShowYear = true;
				fragmentedWords[tempIndex] = LOCKUP_USED_INFORMATION;
				tempIndex++;
				if (fragmentedWords.size() > tempIndex) {      
					if (fragmentedWords[tempIndex] == "to" || fragmentedWords[tempIndex] == "to " ) {    //Check if it is a range between 2 year inputs. E.g. 2015-2016  2015 to 2016
						try {
							tempIndex++;
							if (fragmentedWords.size() > tempIndex) {
								auto tempStoi = std::stoi(fragmentedWords[tempIndex]);
								tempInt = tempStoi;
								fragmentedWords[tempIndex] = LOCKUP_USED_INFORMATION;
								if (tempInt > LOWER_RANGE_YEAR && tempInt < HIGHER_RANGE_YEAR) {
									tempEventStore.setEndDate(31,11,tempInt-TM_YEAR_ADJUSTMENT);
								} 
							}
						} catch (...) {
						}
					}
				}
			} else {
				throw ParserExceptions(ParserExceptions::ERROR_INVALID_YEAR);
			}
		}
	} catch (...) {  //Check if it is system show year, which shows current year
		if (firstWord == "next" || firstWord == "nxt") {
			tempIndex++;
			nextFound = true;
			firstWord = fragmentedWords[tempIndex];
		}
		if (firstWord == "year" || firstWord == "yr") {
			if (nextFound) {
				tempEventStore.setStartDate(1,0,year+1);
				tempEventStore.setEndDate(31,11,year+1);
			} else {
				tempEventStore.setStartDate(day,month,year);
				tempEventStore.setEndDate(31,11,year);
			}
			systemShowYear = true;
		}
	}
	if(systemShowYear){
		logger.logParserIdentified(SHOW_YEAR);
	}
	return systemShowYear;
}

//Verifies if the first word is any of the system show type and assigns Start and End date, or float/importance/deadline according to what was identified. 
//Returns true if the a system based show is identified. 
bool ParserProcessor::checkSystemBasedShow(int tempIndex) {
	Conversion convertor;

	int daysToEndWeek = 0, weekday = 0;
	int day = now->tm_mday;
	int month = now->tm_mon;
	int year = now->tm_year;
	bool nextFound = false;
	std::string firstWord = fragmentedWords[tempIndex];
	
	//Check all system show commands and assign Start and End date accordingly if required
	if (firstWord == "next" || firstWord == "nxt") {
		tempIndex++;
		nextFound = true;
		firstWord = fragmentedWords[tempIndex];
	}
	if (firstWord == "week" || firstWord == "wk") {
		fragmentedWords[tempIndex] = LOCKUP_USED_INFORMATION;
		tempEventStore.setName("week");
		weekday = now->tm_wday;
		daysToEndWeek = 6 - weekday;
		if (nextFound) {
			tempEventStore.setStartDate(day + daysToEndWeek + 1,month,year);
			tempEventStore.setEndDate(day + daysToEndWeek + 1 + NUMBER_OF_DAYSINAWEEK,month,year);
		} else {
			tempEventStore.setStartDate(day,month,year);
			tempEventStore.setEndDate(day + daysToEndWeek,month,year);
		}
		systemShowWeek = true;
	} else if (firstWord == "month" || firstWord == "mth") {
		tempEventStore.setName("month");
		fragmentedWords[tempIndex] = LOCKUP_USED_INFORMATION;
		if (nextFound) {
			tempEventStore.setStartDate(1,month+1,year);
			tempEventStore.setEndDate(convertor.determineLastDayOfMth(month,year),month+1,year);
		} else {
			tempEventStore.setStartDate(day,month,year);
			tempEventStore.setEndDate(convertor.determineLastDayOfMth(month,year),month,year);
		}
		systemShowMonth = true;
	} else if (firstWord == "floating" || firstWord == "float" || firstWord == "all" || firstWord == "important" || firstWord == "impt" 
				|| firstWord == "done" || firstWord == "completed" || firstWord == "complete") {
		tempEventStore.setName(firstWord);
		fragmentedWords[tempIndex] = LOCKUP_USED_INFORMATION;
		systemShowOthers = true;
	} else if (firstWord[0] == '!') {
		int levelImportance = 0;
		for (unsigned int i = 0; i < firstWord.size(); i++) {
			if (firstWord[i] == '!') {
				levelImportance++;
			} else {
				logger.logParserError(ParserExceptions::ERROR_UNUSED_INFORMATION);
				throw ParserExceptions(ParserExceptions::ERROR_UNUSED_INFORMATION);
			}
		}
		tempEventStore.setImportanceLevel(levelImportance);
		tempEventStore.setName("specificimportance");
		fragmentedWords[tempIndex] = LOCKUP_USED_INFORMATION;
		systemShowOthers = true;
	}
	if(systemShowOthers || systemShowWeek || systemShowMonth){
		logger.logParserIdentified(SYSTEM_SHOW);
	}
	return (systemShowOthers || systemShowWeek || systemShowMonth);
}
	
//Checks the string at the current index of the fragmented string vector for the presence of any keywords of days. If found, further operations are 
//performed to determine the day, month and year to complete a date set. A date set will consist of (day, month, year). 
//The number of matches found is recorded, if two matches are found, a range of days is requested to be shown. 
//Throws exception if there are too many dates. Returns matchFound is true if a keyword day is found
bool ParserProcessor::identifyShowDay(int index) {
	Conversion convertor;
	int tempIndex = 0, weekday = 0, currentWeekDay = 0, inputWeekDay = 0, numWdaysApart = 0;
	int day = now->tm_mday;
	int month = now->tm_mon;
	int year = now->tm_year;
	std::string strDay;
	std::string lowerCaseString;

	//Find the presence of keywords based on weekdays (tdy,tmr,mon,tues....)
	for (int j = 0; j < NUMBER_OF_KEYWORDS_DAYS && !matchFound; j++) {
		lowerCaseString = fragmentedWords[index];
		for(unsigned int i = 0; i < lowerCaseString.size(); i++){
			lowerCaseString[i] = std::tolower(lowerCaseString[i]);
		}
		if(findExactWord(lowerCaseString,keywordDay[j])){
			tempIndex = index;
			strDay = keywordDay[j];
			matchFound = true;
			logger.logParserIdentified(IDENTIFY_DAY);
			
			//assigning start and end date according to what keyword was found
			if (strDay == "today" || strDay == "tdy") {
				if (!oneMatchFound) {
					tempEventStore.setStartDate(now->tm_mday,now->tm_mon,now->tm_year);
					oneMatchFound = true;
					userShowDay = true;
				} else if (!twoMatchFound) {
					tempEventStore.setEndDate(now->tm_mday,now->tm_mon,now->tm_year);
					twoMatchFound = true;
					userShowRangeOfDays = true;
					userShowDay = false;
				} else {
					logger.logParserError(ParserExceptions::ERROR_TOO_MANY_DATES);
					throw ParserExceptions(ParserExceptions::ERROR_TOO_MANY_DATES);
				}
			} else if (strDay == "tomorrow" || strDay == "tmr") {
				if (!oneMatchFound) {
					tempEventStore.setStartDate(now->tm_mday+1,now->tm_mon,now->tm_year);
					oneMatchFound = true;
					userShowDay = true;
				} else if (!twoMatchFound) {
					tempEventStore.setEndDate(now->tm_mday+1,now->tm_mon,now->tm_year);
					twoMatchFound = true;
					userShowRangeOfDays = true;
					userShowDay = false;
				} else {
					logger.logParserError(ParserExceptions::ERROR_TOO_MANY_DATES);
					throw ParserExceptions(ParserExceptions::ERROR_TOO_MANY_DATES);
				}
			} else {
				currentWeekDay = now->tm_wday;
				inputWeekDay = convertor.dayOfWeekToInt(strDay);
				//finding number of days from current day to the input week day
				if (inputWeekDay > currentWeekDay) {
					numWdaysApart = inputWeekDay - currentWeekDay;
				} else if (inputWeekDay <= currentWeekDay) {
					numWdaysApart = inputWeekDay -(currentWeekDay - NUMBER_OF_DAYSINAWEEK);
				}
				tempIndex--;
				//checking for next which will add one extra week
				if (tempIndex >= 0) {
					lowerCaseString = fragmentedWords[tempIndex];
					for(unsigned int i = 0; i < lowerCaseString.size(); i++){
						lowerCaseString[i] = std::tolower(lowerCaseString[i]);
					}
					if ((findExactWord(lowerCaseString,"next")) || (findExactWord(lowerCaseString,"nxt"))) {
						numWdaysApart = numWdaysApart + NUMBER_OF_DAYSINAWEEK;
						tempIndex--;
					}
				}
				if (!oneMatchFound) {
					tempEventStore.setStartDate(now->tm_mday+numWdaysApart,now->tm_mon,now->tm_year);
					oneMatchFound = true;
					userShowDay = true;
				} else if (!twoMatchFound) {
					tempEventStore.setEndDate(now->tm_mday+numWdaysApart,now->tm_mon,now->tm_year);
					twoMatchFound = true;
					userShowRangeOfDays = true;
					userShowDay = false;
				} else {
					logger.logParserError(ParserExceptions::ERROR_TOO_MANY_DATES);
					throw ParserExceptions(ParserExceptions::ERROR_TOO_MANY_DATES);
				}
			}
		}
	}
	return matchFound;
}

//Checks the string at the current index of the fragmented string vector for the presence of any keywords of months. If found, further operations are 
//performed to extract the day, month and year from the surrounding strings in the vector to complete a date set. A date set will consist of (day, month, year). 
//The number of matches found is recorded, if two matches are found, a range of days/range of months is requested to be shown. 
//Throws exception if there are too many dates, or if there are unknown or invalid dates. Returns matchFound is true if a date is found.
bool ParserProcessor::identifyShowDate(int index) {
	Conversion convertor;
	std::string strMonth;
	std::string lowerCaseString;
	int tempIndex = 0, indexShift = 0, weekday = 0, dayTo = 0;
	int day = now->tm_mday;
	int month = now->tm_mon;
	int year = now->tm_year;
	
	//Checks current string for any keywords of months
	for (unsigned int j = 0; j < NUMBER_OF_KEYWORDS_MONTHS && !matchFound; j++) {
		lowerCaseString = fragmentedWords[index];
		for(unsigned int i = 0; i < lowerCaseString.size(); i++){
			lowerCaseString[i] = std::tolower(lowerCaseString[i]);
		}
		if(findExactWord(lowerCaseString,keywordMonths[j])){
			matchFound = true;
			logger.logParserIdentified(IDENTIFY_DATE);
			if (!oneMatchFound) {
				oneMatchFound = true;
			} else if (!twoMatchFound) {
				twoMatchFound = true;
			} else {
				logger.logParserError(ParserExceptions::ERROR_TOO_MANY_DATES);
				throw ParserExceptions(ParserExceptions::ERROR_TOO_MANY_DATES);
			}
			tempIndex = index;
			strMonth = keywordMonths[j];
			
			//Retrieving one date set of (day, month, year) from the data
			year = checkYear(tempIndex,&indexShift);
			tempIndex += indexShift;
			day = checkShowDay(tempIndex,&indexShift);
			tempIndex += indexShift;
			month = convertor.monthToInt(strMonth);

			//Confirming the first set of (day, month, year)
			if (userShowDay || userShowRangeOfDays) {
				if ((day > convertor.determineLastDayOfMth(month,year)) || (day < 1)) {
					logger.logParserError(ParserExceptions::ERROR_UNKNOWN_DATE);
					throw ParserExceptions(ParserExceptions::ERROR_UNKNOWN_DATE);
				}
			}

			//Retrieving the second date set of (day, month, year) if 'to' is foun, using previous month and year
			dayTo = checkShowDayTo(tempIndex,&indexShift);
			tempIndex += indexShift;

			//Confirming the second set of (day, month, year)
			if (userShowRangeOfDays) {
				if ((day > convertor.determineLastDayOfMth(month,year)) || (day < 1)) {
					logger.logParserError(ParserExceptions::ERROR_UNKNOWN_DATE);
					throw ParserExceptions(ParserExceptions::ERROR_UNKNOWN_DATE);
				}
			}

			//Assigning the values retrieved into start day or end day of event
			assignShowDate(day,month,year,dayTo);
		}
	}
	return matchFound;
}

//Extracting the day integer, either in the same string as the keyword or in the string before the keyword.
//Return the day as an int if found. 
int ParserProcessor::checkShowDay(int tempIndex, int* indexShift) {
	Conversion convertor;
	int tempInt = 0;
	*indexShift = tempIndex;

	try {
		auto tempStoi = std::stoi(fragmentedWords[tempIndex]);
		fragmentedWords[tempIndex] = LOCKUP_USED_INFORMATION;
		tempInt = tempStoi;
		if (!twoMatchFound) {
			userShowDay = true;
		} else {
			userShowRangeOfDays = true;
			userShowDay = false;
		}
	} catch (...) {
		//no integer found, check if there are any possibility of the day input before the month
		//if no possibility, implies showMonth. if theres a day, implies showDay or showWeek depending
		//whether systemShowDay or systemShowWeek is true
		tempIndex--;
		if (tempIndex >= 0) {
			try {
				auto tempStoi = std::stoi(fragmentedWords[tempIndex]);
				fragmentedWords[tempIndex] = LOCKUP_USED_INFORMATION;
				tempInt = tempStoi;
				if (!twoMatchFound) {
					userShowDay = true;
				} else {
					userShowRangeOfDays = true;
					userShowDay = false;
				}
			} catch(...) {
				if (!twoMatchFound) {
					userShowMonth = true;
				} else {
					userShowRangeOfMonths = true;
					userShowMonth = false;
				}
			}
		} else {
			if (!twoMatchFound) {
				userShowMonth = true;
			} else {
				userShowRangeOfMonths = true;
				userShowMonth = false;
			}
		}
	}
	*indexShift = tempIndex - *indexShift;
	return tempInt;
}

//Checks for 'to' word before a date set. 'to' indicates that the day input before 'to' uses the same month value as the day input after the 'to'.
//Function sets toFound to true if a day before the word 'to' is found. It returns the day if found, or returns 0 if not found. 
int ParserProcessor::checkShowDayTo(int tempIndex, int* indexShift) {
	int tempInt = 0;
	*indexShift = tempIndex; 

	tempIndex--;
	if (tempIndex >= 0) {
		if (fragmentedWords[tempIndex] == "to") {
			tempIndex--;
			if (tempIndex >= 0) {
				try {
					auto tempStoi = std::stoi(fragmentedWords[tempIndex]);
					fragmentedWords[tempIndex] = LOCKUP_USED_INFORMATION;
					tempInt = tempStoi;
					toFound = true;
					logger.logParserIdentified(IDENTIFY_DATE);
					twoMatchFound = true;
					userShowRangeOfDays = true;
					userShowDay = false;
				} catch (...) {
				}
			}
		}
	}
	*indexShift = tempIndex - *indexShift;
	return tempInt;
}

//Inserts values into startDate and endDate based on what Show is found
void ParserProcessor::assignShowDate(int day, int month, int year, int dayTo) {
	Conversion convertor;
	int weekday = 0, daysToEndWeek = 0;
	
	//For handling showing of a day, or a range of days
	if (toFound) {
		tempEventStore.setStartDate(dayTo,month,year);
		tempEventStore.setEndDate(day,month,year);
	} else if (!systemShowWeek) {
		if (userShowDay) {
			tempEventStore.setStartDate(day,month,year);
			tempEventStore.setEndDate(day,month,year);
		} 
		if (userShowRangeOfDays) {
			tempEventStore.setEndDate(day,month,year);
		}
	} else {     //For handling system showing of the week based on a day. E.g. show week 14apr
		time_t t = time(0);
		struct tm* dateWithinWeek = localtime(&t);
		dateWithinWeek->tm_mday = day;
		dateWithinWeek->tm_mon = month;
		dateWithinWeek->tm_year = year;
		mktime(dateWithinWeek);
		weekday = dateWithinWeek->tm_wday;
		daysToEndWeek = 6 - weekday;
		if (userShowDay) {
			tempEventStore.setStartDate(day-weekday,month,year);
			tempEventStore.setEndDate(day+daysToEndWeek,month,year);
		} 
	}

	//For handling system show month. E.g. month   mar   apr
	if (userShowMonth) {
		tempEventStore.setName("month");
		if (year == now->tm_year){
			if (month == now->tm_mon) {
				tempEventStore.setStartDate(now->tm_mday,month,year);
				tempEventStore.setEndDate(convertor.determineLastDayOfMth(month,year),month,year);
			} else {
				tempEventStore.setStartDate(1,month,year);
				tempEventStore.setEndDate(convertor.determineLastDayOfMth(month,year),month,year);
			}
		} else {
			tempEventStore.setStartDate(1,month,year);
			tempEventStore.setEndDate(convertor.determineLastDayOfMth(month,year),month,year);
		}
	}
	//For handling system show range of months. E.g. mar-apr   
	if (userShowRangeOfMonths) {
		tempEventStore.setEndDate(convertor.determineLastDayOfMth(month,year),month,year);
	}
}

void ParserProcessor::showEventCorrector() {
	if (oneMatchFound && !twoMatchFound) { 
		if (userShowDay && !systemShowWeek) {
			struct tm tempDate = tempEventStore.getStartDate();
			tempEventStore.setEndDate(tempDate.tm_mday,tempDate.tm_mon,tempDate.tm_year);
		}
	}
	tempEventStore.setStartTime(0,0);
	tempEventStore.setEndTime(0,0);
}

bool ParserProcessor::findExactWord(std::string input, std::string keyWord){
	bool isExact = true;
	unsigned int i;
	for(i = 0; i < input.size() && i < keyWord.size(); i++){
		if(input[i] != keyWord[i]){
			isExact = false;
		}
	}
	if(isExact){
		if(i != keyWord.size() || i != input.size()){
			isExact= false;
			if(input[i] == ' ' && i == input.size()-1){
				isExact = true;
			}
		}
	}
	return isExact;
}

	// End of segment: D:\Work\NUS\CS2103\Projects\f112c-CS2103\Library\ParserProcessor.cpp





	/**
	 * origin: D:\Work\NUS\CS2103\Projects\f112c-CS2103\Library\ParserProcessor.h
	 */


#pragma once

#ifndef PARSERPROCESSOR_H
#define PARSERPROCESSOR_H

#include <string>
#include <vector>
#include "Event.h"
#include "Conversion.h"
#include "ParserExceptions.h"
#include "ParserLog.h"

class ParserProcessor {
private:
	static const std::string PROCESS_ADD_EVENT;
	static const std::string PROCESS_EDIT_EVENT;
	static const std::string ADD_EVENT_CORRECTOR;
	static const std::string EDIT_EVENT_CORRECTOR;
	static const std::string EVENT_MK_TIME_CORRECTOR;
	static const std::string PROCESS_SHOW_EVENT;
	static const std::string IDENTIFY_EVENT_NAME;
	static const std::string IDENTIFY_DAY;
	static const std::string IDENTIFY_DATE;
	static const std::string IDENTIFY_TIME;
	static const std::string IDENTIFY_DEADLINE;
	static const std::string IDENTIFY_IMPORTANCE;
	static const std::string SYSTEM_SHOW;
	static const std::string SHOW_YEAR;

	static const std::string CONVERT_NORMAL_TO_FLOAT;

	static const int NUMBER_OF_KEYWORDS_MONTHS = 23;
	static const int NUMBER_OF_KEYWORDS_TIME = 2;
	static const int NUMBER_OF_KEYWORDS_DAYS = 18;
	static const int NUMBER_OF_DAYSINAWEEK = 7;

	static const std::string LOCKUP_USED_INFORMATION;
	
	static const int LOWER_RANGE_YEAR = 1970;
	static const int HIGHER_RANGE_YEAR = 3000;
	static const int TM_YEAR_ADJUSTMENT = 1900;
	static const int POSSIBLE_YEAR_INTEGER = 1300;
	static const int INVALID_NUMBER = -1;
	static const int MAX_HOUR = 12;
	static const int MAX_MINUTE = 60;
	static const int MORNING_TIME = 12;
	static const int MIDNIGHT_TIME = 0;
	static const int MORNING_AFTERNOON_DIFFERENTIAL = 12;
	static const int DO_NOT_TOUCH = 100;

	std::string keywordMonths[NUMBER_OF_KEYWORDS_MONTHS];
	std::string keywordTime[NUMBER_OF_KEYWORDS_TIME];
	std::string keywordDay[NUMBER_OF_KEYWORDS_DAYS];
	
	//boolean variables for Add and Edit command
	bool matchFound;
	bool startDayFound;
	bool endDayFound;
	bool startTimeFound;
	bool endTimeFound;
	bool afterTwelve;
	bool nameFound;
	bool firstTriggerKeyword;
	int nameIndex;
	int semiColonIndex;
	bool toFound;
	bool deadlineFound;
	bool importanceFound;
	bool normalToFloat;

	//boolean variables for Show command
	//to check if Show is a range of days 
	bool oneMatchFound;
	bool twoMatchFound;
	//to identify what type of Show 
	bool systemShowDay;
	bool systemShowWeek;
	bool systemShowMonth;
	bool systemShowYear;
	bool systemShowOthers;
	bool userShowDay;
	bool userShowRangeOfDays;
	bool userShowMonth;
	bool userShowRangeOfMonths;

	Event tempEventStore;
	ParserLog logger;
	std::vector<std::string> fragmentedWords;
	struct tm* now;

public:
	struct timeSet {
		int hour;
		int minute;
	};

	ParserProcessor();

	Event processAddEvent(std::vector<std::string>);
	Event processEditEvent(std::vector<std::string>);
	
	bool findExactWord(std::string,std::string);

	bool identifyNormaltoFloat(int);
	int identifyDay(int);

	int identifyDate(int);
	int checkYear(int,int*);
	int checkDay(int,int*);
	int checkDayTo(int,int*);
	void assignDate(int,int,int,int);

	int identifyTime(int);
	int extractFirstTimeInteger(int,int*);
	timeSet extractHourMin(int,int,int*);
	timeSet extractHourMinTo(int,int*);
	void assignTime(timeSet,timeSet);

	int identifyDeadline(int);
	int identifyImportance(int);

	void identifyEventName(int);
	std::string setEventName(int);
	void addEventCorrector();
	void checkStartBeforeEnd();
	void editEventCorrector();
	void eventMktimeCorrector();

	Event processShowEvent(std::vector<std::string>);
	bool checkShowByYear(int);
	bool checkSystemBasedShow(int);
	bool identifyShowDay(int);
	bool identifyShowDate(int);
	int checkShowDay(int,int*);
	int checkShowDayTo(int,int*);
	void assignShowDate(int,int,int,int);
	void showEventCorrector();
};

#endif
	// End of segment: D:\Work\NUS\CS2103\Projects\f112c-CS2103\Library\ParserProcessor.h





	/**
	 * origin: D:\Work\NUS\CS2103\Projects\f112c-CS2103\SystemTest\SystemTest.cpp
	 */


#include "stdafx.h"
#include "CppUnitTest.h"

#include "Logic.cpp"
#include "LogicUpdater.cpp"
#include "Executor.cpp"
#include "Command.cpp"
#include "Conversion.cpp"
#include "EventFacade.cpp"
#include "EventOrganiser.cpp"
#include "EventModifier.cpp"
#include "EventSearch.cpp"
#include "EventStorage.cpp"
#include "Parser.cpp"
#include "ParserProcessor.cpp"
#include "InputStringSplit.cpp"
#include "ParserLog.cpp"
#include "EventLog.cpp"
#include "ParserExceptions.cpp"
#include "Event.cpp"

using namespace Microsoft::VisualStudio::CppUnitTestFramework;

namespace SystemTest
{		
	TEST_CLASS(SystemTest1)
	{
	public:
		
		Logic l;

		TEST_METHOD(System_Add_Event)
		{
			std::string expectedFeedback;
			std::vector<std::string> tempFeedbackVector;

			//Normal events
			//Case 1: Add with no event name
			Assert::AreEqual(l.executeUserInput("add "),false);
			tempFeedbackVector = l.getFeedbackStrings();
			expectedFeedback = "Error: Not enough information to execute command.";
			Assert::AreEqual(tempFeedbackVector.back(),expectedFeedback);

			//Case 2: Add floating
			Assert::AreEqual(l.executeUserInput("add systemtest1;"),true);
			tempFeedbackVector = l.getFeedbackStrings();
			expectedFeedback = "added: systemtest1";
			Assert::AreEqual(tempFeedbackVector.back(),expectedFeedback);
			
			//Case 3: Add normal event
			Assert::AreEqual(l.executeUserInput("add systemtest2; 23-24apr 3-4pm"),true);
			tempFeedbackVector = l.getFeedbackStrings();
			expectedFeedback = "added: systemtest2, 23 April - 24 April 2015";
			Assert::AreEqual(tempFeedbackVector.back(),expectedFeedback);

			//Case 4: Add normal event with invalid dates
			Assert::AreEqual(l.executeUserInput("add systemtest3; 31apr"),false);
			tempFeedbackVector = l.getFeedbackStrings();
			expectedFeedback = "Error: Unknown date input.";
			Assert::AreEqual(tempFeedbackVector.back(),expectedFeedback);

			//Case 5: Add normal event with invalid hour input
			Assert::AreEqual(l.executeUserInput("add systemtest3; 23apr 11-13pm"),false);
			tempFeedbackVector = l.getFeedbackStrings();
			expectedFeedback = "Error: Invalid hour input for time.";
			Assert::AreEqual(tempFeedbackVector.back(),expectedFeedback);

			//Case 6: Add normal event with invalid min input
			Assert::AreEqual(l.executeUserInput("add systemtest3; 23apr 11.30-11.61pm"),false);
			tempFeedbackVector = l.getFeedbackStrings();
			expectedFeedback = "Error: Invalid minutes input for time.";
			Assert::AreEqual(tempFeedbackVector.back(),expectedFeedback);


			//Deadline events
			//Case 2: Add deadline event with no dates
			Assert::AreEqual(l.executeUserInput("add systemtest3; due"),false);
			tempFeedbackVector = l.getFeedbackStrings();
			expectedFeedback = "Error: Wrong formatting, not all information has been successfully recorded.";
			Assert::AreEqual(tempFeedbackVector.back(),expectedFeedback);

			//Case 2: Add deadline event
			Assert::AreEqual(l.executeUserInput("add systemtest3; due 27may 5pm"),true);
			tempFeedbackVector = l.getFeedbackStrings();
			expectedFeedback = "added: systemtest3, 27 May 2015, Wednesday";
			Assert::AreEqual(tempFeedbackVector.back(),expectedFeedback);

			//Case 3: Add deadline event with too many dates
			Assert::AreEqual(l.executeUserInput("add systemtest3; due 22-23may 11pm"),false);
			tempFeedbackVector = l.getFeedbackStrings();
			expectedFeedback = "Error: Exceeded maximum of 1 date input for deadline events.";
			Assert::AreEqual(tempFeedbackVector.back(),expectedFeedback);

			//Case 4: Add deadline event with too many time
			Assert::AreEqual(l.executeUserInput("add systemtest3; due 22may 10-11pm"),false);
			tempFeedbackVector = l.getFeedbackStrings();
			expectedFeedback = "Error: Exceeded maximum of 1 time input for deadline events";
			Assert::AreEqual(tempFeedbackVector.back(),expectedFeedback);

		}

		TEST_METHOD(System_Del_Event)
		{
			std::string expectedFeedback;
			std::vector<std::string> tempFeedbackVector;

			//Case 1: Del with no event name/index
			Assert::AreEqual(l.executeUserInput("del "),false);
			tempFeedbackVector = l.getFeedbackStrings();
			expectedFeedback = "Error: Not enough information to execute command.";
			Assert::AreEqual(tempFeedbackVector.back(),expectedFeedback);
		}

		TEST_METHOD(System_Edit_Event)
		{
			std::string expectedFeedback;
			std::vector<std::string> tempFeedbackVector;
			l.executeUserInput("add systemtest5 28apr 5-6pm");

			//Case 1: Edit with no event name/index
			Assert::AreEqual(l.executeUserInput("edit "),false);
			tempFeedbackVector = l.getFeedbackStrings();
			expectedFeedback = "Error: Not enough information to execute command.";
			Assert::AreEqual(tempFeedbackVector.back(),expectedFeedback);

			//Case 3: Edit event name
			Assert::AreEqual(l.executeUserInput("edit systemtest5; systemtest6"),true);
			tempFeedbackVector = l.getFeedbackStrings();
			expectedFeedback = "edited: systemtest5, 28 April 2015, Tuesday";
			Assert::AreEqual(tempFeedbackVector.back(),expectedFeedback);

			//Case 4: Edit event date
			Assert::AreEqual(l.executeUserInput("edit systemtest6; 30apr"),true);
			tempFeedbackVector = l.getFeedbackStrings();
			expectedFeedback = "edited: systemtest6, 28 April 2015, Tuesday";
			Assert::AreEqual(tempFeedbackVector.back(),expectedFeedback);

			//Case 5: Edit event time
			Assert::AreEqual(l.executeUserInput("edit systemtest6; 10-11pm"),true);
			tempFeedbackVector = l.getFeedbackStrings();
			expectedFeedback = "edited: systemtest6, 30 April 2015, Thursday";
			Assert::AreEqual(tempFeedbackVector.back(),expectedFeedback);

			//Case 5: Multiple edits
			Assert::AreEqual(l.executeUserInput("edit systemtest6; systemtest7 10jun 10am-13jun 11pm"),true);
			tempFeedbackVector = l.getFeedbackStrings();
			expectedFeedback = "edited: systemtest6, 30 April 2015, Thursday";
			Assert::AreEqual(tempFeedbackVector.back(),expectedFeedback);

			//Case 6: Edit floating event
			l.executeUserInput("show float");
			Assert::AreEqual(l.executeUserInput("edit systemtest7; systemtest8"),true);
			tempFeedbackVector = l.getFeedbackStrings();
			expectedFeedback = "edited: systemtest7, 10 June - 13 June 2015";
			Assert::AreEqual(tempFeedbackVector.back(),expectedFeedback);
		}

		TEST_METHOD(System_Show_Event)
		{
			std::string expectedFeedback;
			std::vector<std::string> tempFeedbackVector;
		
			//Case 1: Show with no event name/index
			Assert::AreEqual(l.executeUserInput("show "),false);
			tempFeedbackVector = l.getFeedbackStrings();
			expectedFeedback = "Error: Not enough information to execute command.";
			Assert::AreEqual(tempFeedbackVector.back(),expectedFeedback);

			//Case 2: Show with no registered show-type
			Assert::AreEqual(l.executeUserInput("show cs"),false);
			tempFeedbackVector = l.getFeedbackStrings();
			expectedFeedback = "Error: No registered show found. Please use search instead.";
			Assert::AreEqual(tempFeedbackVector.back(),expectedFeedback);

			//Case 3: System-show type
			Assert::AreEqual(l.executeUserInput("show may"),true);
			tempFeedbackVector = l.getFeedbackStrings();
			expectedFeedback = "showing: 1 May - 31 May 2015";
			Assert::AreEqual(tempFeedbackVector.back(),expectedFeedback);

			//Case 4: User show type
			Assert::AreEqual(l.executeUserInput("show 23-24apr"),true);
			tempFeedbackVector = l.getFeedbackStrings();
			expectedFeedback = "showing: 23 April - 24 April 2015";
			Assert::AreEqual(tempFeedbackVector.back(),expectedFeedback);
		}


	};
}
	// End of segment: D:\Work\NUS\CS2103\Projects\f112c-CS2103\SystemTest\SystemTest.cpp





	/**
	 * origin: D:\Work\NUS\CS2103\Projects\f112c-CS2103\UnitTest\InputStringSplitTest.cpp
	 */


#include "stdafx.h"
#include "CppUnitTest.h"
#include "InputStringSplit.cpp"

using namespace Microsoft::VisualStudio::CppUnitTestFramework;

namespace UnitTest
{
	TEST_CLASS(InputStringSplitTest)
	{
	public:
		
		InputStringSplit splitter;
		std::string testInput;
		std::string testOutput;
		std::string expectedOutput;
		
		//extractFirstWord always find the first instance of a spacing and take what comes before the space
		TEST_METHOD(InputStringSplitTest_extractFirstWord_Test)
		{
			//Case 1: One Word
			testInput = "add";
			testOutput = splitter.extractFirstWord(testInput);
			expectedOutput = "add";
			Assert::AreEqual(expectedOutput,testOutput);

			//Case 2: Multiple Words
			testInput = "add event; 17-18mar";
			testOutput = splitter.extractFirstWord(testInput);
			expectedOutput = "add";
			Assert::AreEqual(expectedOutput,testOutput);
			
			//Case 3: Multiple Words random input
			testInput = "ave;l233 o4,;s lkkk";
			testOutput = splitter.extractFirstWord(testInput);
			expectedOutput = "ave;l233";
			Assert::AreEqual(expectedOutput,testOutput);

			//Case 4: Input with starting spaces
			testInput = "     add hello";
			testOutput = splitter.extractFirstWord(testInput);
			expectedOutput = "add";
			Assert::AreEqual(expectedOutput,testOutput);
		}

		//Finds the first non spacing after the first spacing and takes the whole string after that
		TEST_METHOD(InputStringSplitTest_extractDetails_Test)
		{
			//Case 1: One word
			testInput = "add";
			expectedOutput = ParserExceptions::ERROR_MISSING_INPUT;
			try {
				testOutput = splitter.extractDetails(testInput);
			} catch (ParserExceptions& e){
				testOutput = e.getExceptionCode();
			}
			Assert::AreEqual(expectedOutput,testOutput);

			//Case 2: One word plus spaces and symbols
			testInput = "del     ;;;";
			testOutput = splitter.extractDetails(testInput);
			expectedOutput = ";;;";
			Assert::AreEqual(expectedOutput,testOutput);

			//Case 3: Multiple Words
			testInput = "add event; 17-18mar";
			testOutput = splitter.extractDetails(testInput);
			expectedOutput = "event; 17-18mar";
			Assert::AreEqual(expectedOutput,testOutput);
			
			//Case 4: Multiple Words random input
			testInput = "ave;l233 o4,;s lkkk";
			testOutput = splitter.extractDetails(testInput);
			expectedOutput = "o4,;s lkkk";
			Assert::AreEqual(expectedOutput,testOutput);

			//Case 5: Input with starting spaces
			testInput = "     add";
			expectedOutput = ParserExceptions::ERROR_MISSING_INPUT;
			try { 
				testOutput = splitter.extractDetails(testInput);
			} catch (ParserExceptions& e){
				testOutput = e.getExceptionCode();
			}
			Assert::AreEqual(expectedOutput,testOutput);
		}
		
		//Extracts the index of the event, or the event name if index is not found
		TEST_METHOD(InputStringSplitTest_extractEditEventName_Test)
		{
			//Case 1: Editting by index
			testInput = "13; 24-25apr 9pm";
			testOutput = splitter.extractEditEventName(testInput);
			expectedOutput = "13";
			Assert::AreEqual(expectedOutput,testOutput);
			
			//Case 2: Editting by event name
			testInput = "event name12345; 24-25apr 9pm";
			testOutput = splitter.extractEditEventName(testInput);
			expectedOutput = "event name12345";
			Assert::AreEqual(expectedOutput,testOutput);

			//Case 3: Editting by event name with number in front
			testInput = "21 jump street; 24-25apr 9pm";
			testOutput = splitter.extractEditEventName(testInput);
			expectedOutput = "21 jump street";
			Assert::AreEqual(expectedOutput,testOutput);

			//Case 4: Many inputs but no ; to indicate name
			testInput = "jump street";
			expectedOutput = ParserExceptions::ERROR_MISSING_INDEX;
			try {
				testOutput = splitter.extractEditEventName(testInput);
			} catch (ParserExceptions& e){
				testOutput = e.getExceptionCode();
			}
			Assert::AreEqual(expectedOutput,testOutput);

			//Case 5: One input, no name, no index
			testInput = "jumpstreet";
			expectedOutput = ParserExceptions::ERROR_MISSING_INDEX;
			try {
				testOutput = splitter.extractEditEventName(testInput);
			} catch (ParserExceptions& e){
				testOutput = e.getExceptionCode();
			}
			Assert::AreEqual(expectedOutput,testOutput);
		}

		//Removes the index of the event, or the event name from the string
		TEST_METHOD(InputStringSplitTest_removeEditEventName_Test)
		{
			std::string eventName;

			//Case 1: Remove name with no additional input after that
			testInput = "jumpstreet;";
			eventName = splitter.extractEditEventName(testInput);
			expectedOutput = "";
			Assert::AreEqual(expectedOutput,testOutput);

			//Case 2: Remove index with no additional input after that
			testInput = "21;";
			eventName = splitter.extractEditEventName(testInput);
			testOutput = splitter.removeEditEventName(testInput,eventName);
			expectedOutput = "to>>>float";
			Assert::AreEqual(expectedOutput,testOutput);

			//Case 3: Remove by index
			testInput = "13; 24-25apr 9pm";
			eventName = splitter.extractEditEventName(testInput);
			testOutput = splitter.removeEditEventName(testInput,eventName);
			expectedOutput = "24-25apr 9pm";
			Assert::AreEqual(expectedOutput,testOutput);
			
			//Case 4: Remove by event name
			testInput = "event name12345; 24-25apr 9pm";
			eventName = splitter.extractEditEventName(testInput);
			testOutput = splitter.removeEditEventName(testInput,eventName);
			expectedOutput = "24-25apr 9pm";
			Assert::AreEqual(expectedOutput,testOutput);

			//Case 5: Remove name with number at the front
			testInput = "21 jump street; 24-25apr 9pm";
			eventName = splitter.extractEditEventName(testInput);
			testOutput = splitter.removeEditEventName(testInput,eventName);
			expectedOutput = "24-25apr 9pm";
			Assert::AreEqual(expectedOutput,testOutput);
		}

		//Fragment the input string by taking out delimiters such as " .-"
		TEST_METHOD(InputStringSplitTest_fragmentString_Test)
		{
			std::vector<std::string> fragmentedWords;
			std::string expectedOutput0;
			std::string expectedOutput1;
			std::string expectedOutput2;
			std::string expectedOutput3;
			std::string expectedOutput4;
			std::string expectedOutput5;
			std::string expectedOutput6;
			std::string expectedOutput7;
			std::string expectedOutput8;
			std::string expectedOutput9;
			std::string expectedOutput10;
			std::string expectedOutput11;
			std::string expectedOutput12;

			//Case 1: One word
			testInput = "event";
			expectedOutput0 = "event";
			fragmentedWords = splitter.fragmentString(testInput);
			testOutput = fragmentedWords[0];
			Assert::AreEqual(expectedOutput0,testOutput);

			//Case 2: Event name only (floating events)
			testInput = "event name12345;";
			fragmentedWords = splitter.fragmentString(testInput);
			expectedOutput0 = "event ";
			expectedOutput1 = "name";
			expectedOutput2 = "12345";
			expectedOutput3 = ";";
			Assert::AreEqual(expectedOutput0,fragmentedWords[0]);
			Assert::AreEqual(expectedOutput1,fragmentedWords[1]);
			Assert::AreEqual(expectedOutput2,fragmentedWords[2]);
			Assert::AreEqual(expectedOutput3,fragmentedWords[3]);
			
			//Case 3: Add normal event
			testInput = "event name12345; 24-25apr 9am-10pm";
			fragmentedWords = splitter.fragmentString(testInput);
			expectedOutput0 = "event ";
			expectedOutput1 = "name";
			expectedOutput2 = "12345";
			expectedOutput3 = "; ";
			expectedOutput4 = "24";
			expectedOutput5 = "to";
			expectedOutput6 = "25";
			expectedOutput7 = "apr ";
			expectedOutput8 = "9";
			expectedOutput9 = "am";
			expectedOutput10 = "to";
			expectedOutput11 = "10";
			expectedOutput12 = "pm";
			Assert::AreEqual(expectedOutput0,fragmentedWords[0]);
			Assert::AreEqual(expectedOutput1,fragmentedWords[1]);
			Assert::AreEqual(expectedOutput2,fragmentedWords[2]);
			Assert::AreEqual(expectedOutput3,fragmentedWords[3]);
			Assert::AreEqual(expectedOutput4,fragmentedWords[4]);
			Assert::AreEqual(expectedOutput5,fragmentedWords[5]);
			Assert::AreEqual(expectedOutput6,fragmentedWords[6]);
			Assert::AreEqual(expectedOutput7,fragmentedWords[7]);
			Assert::AreEqual(expectedOutput8,fragmentedWords[8]);
			Assert::AreEqual(expectedOutput9,fragmentedWords[9]);
			Assert::AreEqual(expectedOutput10,fragmentedWords[10]);
			Assert::AreEqual(expectedOutput11,fragmentedWords[11]);
			Assert::AreEqual(expectedOutput12,fragmentedWords[12]);

			//Case 4: Add with random input
			testInput = "gvtr d'kfnd;;; ndfv-nlksn' lkfdnv. dkl";
			fragmentedWords = splitter.fragmentString(testInput);
			expectedOutput0 = "gvtr ";
			expectedOutput1 = "d'kfnd;;; ";
			expectedOutput2 = "ndfv";
			expectedOutput3 = "to";
			expectedOutput4 = "nlksn' ";
			expectedOutput5 = "lkfdnv. ";
			expectedOutput6 = "dkl";
			Assert::AreEqual(expectedOutput0,fragmentedWords[0]);
			Assert::AreEqual(expectedOutput1,fragmentedWords[1]);
			Assert::AreEqual(expectedOutput2,fragmentedWords[2]);
			Assert::AreEqual(expectedOutput3,fragmentedWords[3]);
			Assert::AreEqual(expectedOutput4,fragmentedWords[4]);
			Assert::AreEqual(expectedOutput5,fragmentedWords[5]);
			Assert::AreEqual(expectedOutput6,fragmentedWords[6]);
		}
	};
}
	// End of segment: D:\Work\NUS\CS2103\Projects\f112c-CS2103\UnitTest\InputStringSplitTest.cpp





	/**
	 * origin: D:\Work\NUS\CS2103\Projects\f112c-CS2103\UnitTest\ParserProcessorTest.cpp
	 */


#include "stdafx.h"
#include "CppUnitTest.h"
#include "ParserProcessor.cpp"

using namespace Microsoft::VisualStudio::CppUnitTestFramework;

namespace UnitTest
{
	TEST_CLASS(ParserProcessorTest)
	{
	public:
		ParserProcessor processor;
		Event expectedOutput;
		std::vector<std::string> testInput;
		
		//extractFirstWord always find the first instance of a spacing and take what comes before the space
		TEST_METHOD(ParserProcessor_processAddEvent_Test)
		{
			//Case 1: One word, event name only
			Event testOutput1;
			testInput.push_back("hello");
			expectedOutput.setName("hello");
			expectedOutput.setStartDate(0,0,0);
			expectedOutput.setEndDate(0,0,0);
			expectedOutput.setStartTime(0,0);
			expectedOutput.setIsDeadline(false);
			expectedOutput.setIsFloating(true);
			expectedOutput.setIsCompleted(false);
			expectedOutput.setImportanceLevel(0);
			testOutput1 = processor.processAddEvent(testInput);
			Assert::AreEqual(expectedOutput.getName(),testOutput1.getName());
			Assert::AreEqual(expectedOutput.getStartDate().tm_mday,testOutput1.getStartDate().tm_mday);
			Assert::AreEqual(expectedOutput.getStartDate().tm_mon,testOutput1.getStartDate().tm_mon);
			Assert::AreEqual(expectedOutput.getStartDate().tm_year,testOutput1.getStartDate().tm_year);
			Assert::AreEqual(expectedOutput.getStartDate().tm_hour,testOutput1.getStartDate().tm_hour);
			Assert::AreEqual(expectedOutput.getStartDate().tm_min,testOutput1.getStartDate().tm_min);
			Assert::AreEqual(expectedOutput.getIsDeadline(),testOutput1.getIsDeadline());
			Assert::AreEqual(expectedOutput.getIsFloating(),testOutput1.getIsFloating());
			Assert::AreEqual(expectedOutput.getIsCompleted(),testOutput1.getIsCompleted());
			Assert::AreEqual(expectedOutput.getImportanceLevel(),testOutput1.getImportanceLevel());

			testInput.clear();

			//Case 2: Full event information
			Event testOutput2;
			testInput.push_back("testing1 testing2 ");
			testInput.push_back("!! ");
			testInput.push_back("22");
			testInput.push_back("apr ");
			testInput.push_back("3");
			testInput.push_back("am ");
			testInput.push_back("to");
			testInput.push_back("3");
			testInput.push_back("may ");
			testInput.push_back("5.30");
			testInput.push_back("pm ");
			expectedOutput.setName("testing1 testing2");
			expectedOutput.setStartDate(22,3,115);
			expectedOutput.setEndDate(3,4,115);
			expectedOutput.setStartTime(3,0);
			expectedOutput.setEndTime(17,30);
			expectedOutput.setIsDeadline(false);
			expectedOutput.setIsFloating(false);
			expectedOutput.setIsCompleted(false);
			expectedOutput.setImportanceLevel(2);
			testOutput2 = processor.processAddEvent(testInput);
			Assert::AreEqual(expectedOutput.getName(),testOutput2.getName());
			Assert::AreEqual(expectedOutput.getStartDate().tm_mday,testOutput2.getStartDate().tm_mday);
			Assert::AreEqual(expectedOutput.getStartDate().tm_mon,testOutput2.getStartDate().tm_mon);
			Assert::AreEqual(expectedOutput.getStartDate().tm_year,testOutput2.getStartDate().tm_year);
			Assert::AreEqual(expectedOutput.getStartDate().tm_hour,testOutput2.getStartDate().tm_hour);
			Assert::AreEqual(expectedOutput.getStartDate().tm_min,testOutput2.getStartDate().tm_min);
			Assert::AreEqual(expectedOutput.getEndDate().tm_mday,testOutput2.getEndDate().tm_mday);
			Assert::AreEqual(expectedOutput.getEndDate().tm_mon,testOutput2.getEndDate().tm_mon);
			Assert::AreEqual(expectedOutput.getEndDate().tm_year,testOutput2.getEndDate().tm_year);
			Assert::AreEqual(expectedOutput.getEndDate().tm_hour,testOutput2.getEndDate().tm_hour);
			Assert::AreEqual(expectedOutput.getEndDate().tm_min,testOutput2.getEndDate().tm_min);
			Assert::AreEqual(expectedOutput.getIsDeadline(),testOutput2.getIsDeadline());
			Assert::AreEqual(expectedOutput.getIsCompleted(),testOutput2.getIsCompleted());
			Assert::AreEqual(expectedOutput.getImportanceLevel(),testOutput2.getImportanceLevel());

			testInput.clear();
		}
	
		TEST_METHOD(ParserProcessor_processEditEvent_Test)
		{
			//Case 1: One word, event name only
			Event testOutput1;
			testInput.push_back("hello");
			expectedOutput.setName("hello");
			expectedOutput.setStartDate(100,100,100);
			expectedOutput.setEndDate(100,100,100);
			expectedOutput.setStartTime(100,100);
			expectedOutput.setIsDeadline(false);
			expectedOutput.setIsFloating(false);
			expectedOutput.setIsCompleted(false);
			expectedOutput.setImportanceLevel(0);
			testOutput1 = processor.processEditEvent(testInput);
			Assert::AreEqual(expectedOutput.getName(),testOutput1.getName());
			Assert::AreEqual(expectedOutput.getStartDate().tm_mday,testOutput1.getStartDate().tm_mday);
			Assert::AreEqual(expectedOutput.getStartDate().tm_mon,testOutput1.getStartDate().tm_mon);
			Assert::AreEqual(expectedOutput.getStartDate().tm_year,testOutput1.getStartDate().tm_year);
			Assert::AreEqual(expectedOutput.getStartDate().tm_hour,testOutput1.getStartDate().tm_hour);
			Assert::AreEqual(expectedOutput.getStartDate().tm_min,testOutput1.getStartDate().tm_min);
			Assert::AreEqual(expectedOutput.getIsDeadline(),testOutput1.getIsDeadline());
			Assert::AreEqual(expectedOutput.getIsFloating(),testOutput1.getIsFloating());
			Assert::AreEqual(expectedOutput.getIsCompleted(),testOutput1.getIsCompleted());
			Assert::AreEqual(expectedOutput.getImportanceLevel(),testOutput1.getImportanceLevel());

			testInput.clear();

			//Case 2: Full event information
			Event testOutput2;
			testInput.push_back("testing1 testing2 ");
			testInput.push_back("!! ");
			testInput.push_back("22");
			testInput.push_back("apr ");
			testInput.push_back("3");
			testInput.push_back("am ");
			testInput.push_back("to");
			testInput.push_back("3");
			testInput.push_back("may ");
			testInput.push_back("5.30");
			testInput.push_back("pm ");
			expectedOutput.setName("testing1 testing2");
			expectedOutput.setStartDate(22,3,115);
			expectedOutput.setEndDate(3,4,115);
			expectedOutput.setStartTime(3,0);
			expectedOutput.setEndTime(17,30);
			expectedOutput.setIsDeadline(false);
			expectedOutput.setIsFloating(false);
			expectedOutput.setIsCompleted(false);
			expectedOutput.setImportanceLevel(2);
			testOutput2 = processor.processEditEvent(testInput);
			Assert::AreEqual(expectedOutput.getName(),testOutput2.getName());
			Assert::AreEqual(expectedOutput.getStartDate().tm_mday,testOutput2.getStartDate().tm_mday);
			Assert::AreEqual(expectedOutput.getStartDate().tm_mon,testOutput2.getStartDate().tm_mon);
			Assert::AreEqual(expectedOutput.getStartDate().tm_year,testOutput2.getStartDate().tm_year);
			Assert::AreEqual(expectedOutput.getStartDate().tm_hour,testOutput2.getStartDate().tm_hour);
			Assert::AreEqual(expectedOutput.getStartDate().tm_min,testOutput2.getStartDate().tm_min);
			Assert::AreEqual(expectedOutput.getEndDate().tm_mday,testOutput2.getEndDate().tm_mday);
			Assert::AreEqual(expectedOutput.getEndDate().tm_mon,testOutput2.getEndDate().tm_mon);
			Assert::AreEqual(expectedOutput.getEndDate().tm_year,testOutput2.getEndDate().tm_year);
			Assert::AreEqual(expectedOutput.getEndDate().tm_hour,testOutput2.getEndDate().tm_hour);
			Assert::AreEqual(expectedOutput.getEndDate().tm_min,testOutput2.getEndDate().tm_min);
			Assert::AreEqual(expectedOutput.getIsDeadline(),testOutput2.getIsDeadline());
			Assert::AreEqual(expectedOutput.getIsCompleted(),testOutput2.getIsCompleted());
			Assert::AreEqual(expectedOutput.getImportanceLevel(),testOutput2.getImportanceLevel());

			testInput.clear();
		}

		TEST_METHOD(ParserProcessor_processShowEvent_Test)
		{
			//Case 1: Single day
			Event testOutput1;
			testInput.push_back("24");
			testInput.push_back("apr");
			expectedOutput.setName("");
			expectedOutput.setStartDate(24,3,115);
			expectedOutput.setEndDate(24,3,115);
			expectedOutput.setStartTime(0,0);
			expectedOutput.setIsDeadline(false);
			expectedOutput.setIsFloating(false);
			expectedOutput.setIsCompleted(false);
			expectedOutput.setImportanceLevel(0);
			testOutput1 = processor.processShowEvent(testInput);
			Assert::AreEqual(expectedOutput.getName(),testOutput1.getName());
			Assert::AreEqual(expectedOutput.getStartDate().tm_mday,testOutput1.getStartDate().tm_mday);
			Assert::AreEqual(expectedOutput.getStartDate().tm_mon,testOutput1.getStartDate().tm_mon);
			Assert::AreEqual(expectedOutput.getStartDate().tm_year,testOutput1.getStartDate().tm_year);
			Assert::AreEqual(expectedOutput.getStartDate().tm_hour,testOutput1.getStartDate().tm_hour);
			Assert::AreEqual(expectedOutput.getStartDate().tm_min,testOutput1.getStartDate().tm_min);
			Assert::AreEqual(expectedOutput.getIsDeadline(),testOutput1.getIsDeadline());
			Assert::AreEqual(expectedOutput.getIsFloating(),testOutput1.getIsFloating());
			Assert::AreEqual(expectedOutput.getIsCompleted(),testOutput1.getIsCompleted());
			Assert::AreEqual(expectedOutput.getImportanceLevel(),testOutput1.getImportanceLevel());

			testInput.clear();

			//Case 2: Multiple days
			Event testOutput2;
			testInput.push_back("22");
			testInput.push_back("to");
			testInput.push_back("25");
			testInput.push_back("may");
			expectedOutput.setName("");
			expectedOutput.setStartDate(22,4,115);
			expectedOutput.setEndDate(25,4,115);
			expectedOutput.setStartTime(0,0);
			expectedOutput.setEndTime(0,0);
			expectedOutput.setIsDeadline(false);
			expectedOutput.setIsFloating(false);
			expectedOutput.setIsCompleted(false);
			expectedOutput.setImportanceLevel(0);
			testOutput2 = processor.processShowEvent(testInput);
			Assert::AreEqual(expectedOutput.getName(),testOutput2.getName());
			Assert::AreEqual(expectedOutput.getStartDate().tm_mday,testOutput2.getStartDate().tm_mday);
			Assert::AreEqual(expectedOutput.getStartDate().tm_mon,testOutput2.getStartDate().tm_mon);
			Assert::AreEqual(expectedOutput.getStartDate().tm_year,testOutput2.getStartDate().tm_year);
			Assert::AreEqual(expectedOutput.getStartDate().tm_hour,testOutput2.getStartDate().tm_hour);
			Assert::AreEqual(expectedOutput.getStartDate().tm_min,testOutput2.getStartDate().tm_min);
			Assert::AreEqual(expectedOutput.getEndDate().tm_mday,testOutput2.getEndDate().tm_mday);
			Assert::AreEqual(expectedOutput.getEndDate().tm_mon,testOutput2.getEndDate().tm_mon);
			Assert::AreEqual(expectedOutput.getEndDate().tm_year,testOutput2.getEndDate().tm_year);
			Assert::AreEqual(expectedOutput.getEndDate().tm_hour,testOutput2.getEndDate().tm_hour);
			Assert::AreEqual(expectedOutput.getEndDate().tm_min,testOutput2.getEndDate().tm_min);
			Assert::AreEqual(expectedOutput.getIsDeadline(),testOutput2.getIsDeadline());
			Assert::AreEqual(expectedOutput.getIsCompleted(),testOutput2.getIsCompleted());
			Assert::AreEqual(expectedOutput.getImportanceLevel(),testOutput2.getImportanceLevel());

			testInput.clear();
		}
	};
}
	// End of segment: D:\Work\NUS\CS2103\Projects\f112c-CS2103\UnitTest\ParserProcessorTest.cpp





